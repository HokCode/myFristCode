20.初始化列表

	(1)利用初始化列表初始化成员变量
		
		1.格式：
			classname::classname : m1(v1)， m2(v2), m3(v3)
			{
				/..
			}
	
		2.成员的初始化顺序与成员的声明顺序相同，与初始化列表中的位置无关。
		
		3.初始化列表会先于构造函数的函数体前执行。构造函数函数体执行时，对象已经构建完毕。所以应在对象构建同时初始化。

	(2)类中的const
		
		1.会被分配空间；本质是只读变量；只能在初始化列表中指定初始值。
		
	(3)初始化与赋值差异
		
		1.初始化：对正在创建的对象进行处置设置。
		
		2.赋值：对已经存在的对象进行值设置。  

21.对象构造顺序
	
	(1)局部对象
		
		1.当程序执行流到达对象的定义语句时，局部对象进行构造。

	(2)堆对象
		
		1.当程序执行流到达new语句时创建对象。堆对象的构建顺序依赖于new的使用顺序。
		
		2.使用new创建对象将自动触发构造函数的调用。
		
			Test* a1 = new Test(1);
			new Test(i);

	(3)全局对象
		
		1.全局对象构造顺序不确定，不同的编译器使用不同的规则确定构造顺序。

		2.文件流从main函数开始，所以无法用来判断全局对象构造顺序。
		
		3.软件开发时尽量避免全局对象的相互依赖。

22.对象的销毁
	
	(1)析构函数
		
		1.定义：~ClassName()。
		
		2.析构函数没有参数也没有返回值类型声明；在对象销毁时自动被调用。

	(2)析构函数的定义准则
		
		1.当类中自定义了构造函数，并且构造函数中使用了系统资源(内存申请、文件打开等)，则需要自定义析构函数。

23.临时对象	
	
	(1)临时对象解析
		
		1.直接调用构造函数将产生一个临时对象。
		
		2.临时对象的生命周期只有一条语句的时间。
		
		3.临时对象的作用域只在一条语句中。
		
	(2)临时对象意义
		
		1.软件开发会尽量避免临时对象，提升效率。

		2.编译器在不影响最终结果的情况下，会尽量避免临时对象。

24.经典问题分析
	
	(1)对象析构过程
		
		析构顺序与构造顺序相反。构造顺序为：
		
		1.调用父类的构造过程
		
		2.调用成员变量的构造函数(调用顺序与声明顺序相同)。
		
		3.调用类自身的构造函数

		对象析构顺序：
		
		1.对于栈对象和全局对象，最新构造的对象被最先析构。
		
		2.对于堆对象，与delete的使用顺序相关。

	(2)const对象
		
		1.const修饰的对象为只读对象。
		
		2.只读对象的成员变量不允许被改变；这是编译阶段的概念，运行时无效。
				
		3.const对象只能调用const成员函数。

	(3)const成员函数
		
		1.const成员函数中只能调用const成员函数。
		
		2.const成员函数中不能直接改写成员变量的值。
		
		3.const成员函数只能返回值，不能返回函数。

		4.const成员函数声明和定义格式：
			
			Type ClassName::function(Type p) const
			
	(4)对象中的成员函数
		
		1.每个对象都拥有自己的一套成员变量，但所有对象共用一套成员函数。因为函数位于代码段，程序运行时不能改变。
		
		2.成员函数中有一个隐藏参数this指针，用于指代当前调用函数的对象。this实质是指向当前对象地址的指针。


