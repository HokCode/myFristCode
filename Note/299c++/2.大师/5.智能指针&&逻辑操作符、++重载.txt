37.智能指针分析
	
	(1)重载指针特征操作符(->和*)
		
		1.只能通过类的成员函数重载。
		
		2.重载函数不能使用参数。
		
		3.只能定义个一个重载函数。

	(2)智能指针的使用规则
		
		1.只能用来指向堆空间中的对象或者变量。

	(3)智能指针可实现
		
		1.指针声明周期结束时主动释放堆空间。
		
		2.一片堆空间最多只能由一个指针标识。
		
		3.杜绝指针的运算和比较。

38.逻辑操作符(&&、||)的陷阱
	
	(1)逻辑运算符原生语义
		
		1.操作数只有两种值(true和false)。
		
		2.不用完全计算就能确定最终值。
		
		3.最终结果只有两种值(true和false)。

	(2)重载后本质分析
		
		1.进入重载函数体前必须完成所有参数的计算。
		
		2.函数参数的计算次序是不定的。

	(3)结论
	
		1.重载裸机操作符无法实现逻辑操作符原生语义。

		2.实际过程避免重载逻辑操作符。

		3.可通过重载比较操作符、专用成员函数替换。

39.逗号操作符重载
	
	(1)逗号操作符(,)
		
		1.用于将多个子表达式连接为一个表达式。
		
		2.值为最后一个子表达式的值。
		
		3.前N-1个子表达式可以没有返回值。
		
		4.按照从左到右的顺序计算每个子表达式的值。

	(2)重载规定
		
		1.使用全局函数进行重载。
		
		2.参数必须有一个类类型。
		
		3.返回值类型必须是引用。

	(3)总结
		
		1.因为逗号操作符重载与逻辑操作符相同，重载后无法完全实现其原生意义。
		
		2.工程开发中不必重载逗号操作符。

40.前置操作符和后置操作符
	
	(1)i++和++i的区别
		
		1.在工程上没区别，编译器会将其优化为相同代码。效率基本相同。

		2.优化后二进制程序更高效，但丢失了C/C++的原生语义。
		
	(2)重载++操作符
		
		1.全局函数和成员函数均可重载。
		
		2.重载前置++操作符不需额外参数。
		
		3.重载后置++操作符需要一个int类型的占位参数。

			前置++
			Type& operator ++ ()
			{
				++mvalue;
				return *this;
			}

			后置++
			Type operator ++ (int)
			{
				Text ret(mvalue);
				mvalue++;
				return ret;
			}
	
	(3)对类类型的i++和++i的区别

		1.前置++的效率高于后置++。

