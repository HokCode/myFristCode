53.多重继承1
	
	(1)c++支持多重继承
		
		1.一个子类可拥有多个父类。拥有所有父类的成员变量，继承所有父类的成员函数。
		
		2.子类对象可当作任意父类对象使用。

		3.语法法则：
			
			class Child : public Base A,
						  public Base B,
						  public Base C
						  
			{
				//..
			};

	(2)多重继承的问题
		
		1.通过多重继承得到的对象可拥有"不同地址"。两个不同基类的指针会指向同一个对象的不同位置。

		2.当其中两个基类有交叉关系时，可能产生冗余的成员，导致二义性。

	(3)虚继承
		
		1.虚继承可以解决多重继承导致的数据冗余问题。
		
		2.但会导致中间层父类不再进行顶层父类的初始化，最终子类必须直接调用顶层父类的构造函数。
		
		3.虚继承函数会导致程序效率变低，复杂度变高。不适合实际的工程项目开发。
		
		4.语法规则：
			
			class Child : virtual public Parent A
			{
				//..
			};

54.多重继承2
	
	(1)多重继承的强制类型转换
		
		derived d;
		BaseA* pa = &d;
		BaseB* pb = &d;
		BaseB* pbb = dynamic_cast<BastB*>(pa);
		
		1.与虚函数相关的类型转换应使用dynamic_cast关键字进行转换。

		2.此时pbb实际指向的是pb指向的位置。

	(2)正确的多重继承方式
		
		1.单继承某个父类，同时实现多个接口。

		2.父类中提供equal()成员函数用于判断指针是否指向当前对象。

55.经典问题分析1
	
	(1)new和malloc
		
		1.new是c++的一部分；malloc是c的一个库函数。

		2.new可以触发构造函数的调用，malloc仅仅只申请内存空间。
		3.free释放new申请的堆对象所在空间时，不会调用堆对象的析构函数。

		4.new和malloc、delete和free不能混用。
		
	(2)构造函数、析构函数和虚函数
	
		1.构造函数不能成为虚函数。在构造函数执行结束后，虚函数表指针才会被正确的初始化。

		2.析构函数可成为虚函数。在设计类时将析构函数声明为虚函数，可防止释放堆内存时产生内存泄漏。

		3.构造函数和析构函数内部不能发生多态行为。函数中如果调用虚函数，则只可调用当前类中定义的函数版本。

	(3)dynamic_cast关键字
		
		1.与继承相关的类型转换关键字，要求相关类中必须有虚函数。
		
		2.用于有直接或间接继承关系的指针(引用)之间。

		3.dynamic_cast转换失败会返回0。

56.函数模板的概念和意义
	
	(1)泛型编程
		
		1.不考虑具体数据类型的编程方式。如对某个函数用泛型写法：
			
			template<typename T>
			void Swap(T& a, T& b)
			{
				T t = a;
				a = b;
				b = c;
			}
			
			-template关键字用于声明开始进行泛型编程。
			-typename关键字用于声明泛指类型。
		
	(2)函数模板
		
		1.泛型编程在c++的应用方式之一。
		
		2.能够根据实参对参数类型进行推导。
		
		3.支持显示的制定参数类型。
		
		4.c++中重要的代码复用方式。

57.深入理解函数模板1
	
	(1)编译器对于函数模板
		
		1.编译器从函数模板通过具体类型产生不同的函数。
		
		2.编译器会先对模板本身进行编译；再对参数替换后的代码进行编译。

	(2)函数模板不允许隐式类型转换
	
		1.自动推导类型时，必须严格匹配。
		
		2.显示类型指定时，能够进行隐式类型转换。

57.深入理解函数模板2

	(1)定义参数
	
		1.函数模板可以定义任意多个不同的类型参数
		
			template
			< typename T1, typename T2, typename T3 >
			T1 Add(T2 a, T3 b)
			{
				return static_cast<T1>(a + b);
			}
		
		2.对于多参数函数模板，可以从左向右部分指定类型参数。返回值类型通常摆在第一位，并手工显示指定：
			
			int r1 = ADD<int>(0.5, 0.8);
			int r1 = ADD<int,float>(0.5, 0.8);
			int r1 = ADD<int,float,float>(0.5, 0.8);
			
57.深入理解函数模板3
			
	(1)函数模板和函数重载
		
		1.c++编译器会优先考虑普通函数。
		
		2.如果函数模板可产生一个更好的匹配，则选择模板。
		
		3.可通过空模板实参列表限定编译器只会匹配模板：
			
			double r2 = Max<>(0.5, 0.8);
			
	(2)工程中应用函数模板
		
		1.当需要重载函数模板时，优先考虑使用模板特化。
		
		2.模板特化无法满足需求时，再使用函数重载。
			
	