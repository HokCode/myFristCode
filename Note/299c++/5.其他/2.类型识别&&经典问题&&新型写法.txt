66.c++中的类型识别
	
	(1)类型介绍
	
		静态类型：变量(对象)自身的类型。
	
		动态类型：指针(引用)所指向对象的实际类型。
	
	(2)利用多态进行动态类型识别
		
		1.在基类中定义虚函数返回具体的类型信息。
		
		2.所有派生类都必须实现类型相关的虚函数。

	(3)typeid关键字(<typeinfo>)
		
		1.用于返回对应参数的类型信息。

		2.返回一个type_info类对象，里面有类型信息。
		
		3.当typeid的参数为NULL时将抛出异常。

	(4)typeid注意事项
	
		1.当参数为类型时：返回静态类型信息。
		
		2.当参数为变量时：
			
			-不存在虚函数表：返回静态类型信息。
			-存在虚函数表：返回动态类型信息。
			
	(5)使用事例：(Base为一个基类)
		
		void print(Base* b)
		{
			const type_info& t = typeid(*b);
			cout<< t.name() <<endl;
		}

67.经典问题解析

	(1)C++编译器的匹配调用优先级：
		
		重载函数->函数模板->变参函数

		1.变参函数格式：
			
			Test(...)
			{
			}
		
	(2)判断一个元素是否为指针技巧：
		
		1.利用函数模板和变参函数。
		
		2.利用sizeof直接计算编译器匹配函数返回值的大小，避开编译器的实际调用。
	
			template
			<typename T>
			char Isprt(T *t)
			{
				return"d";	//返回任意char类型即可
			}
			
			int Isprt(...)
			{
				return 0;
			}

			#define ISPRT(p) (sizeof(Isprt(p))) == sizeof(char)

67.经典问题解析
			
	(1)构造函数抛出异常
		
		1.当前对象无法生成，不会调用析构函数。
		
		2.对象所占用的空间立即回收。

		3.工程项目中尽量不要在构造函数中抛出异常，当构造函数可能产异常时，使用二阶构造法。
		
	(2)析构函数抛出异常
		
		1.会导致对象所使用的资源无法完全释放。

68.疑惑写法
	
	(1)template中的typename和class
		
		1.class也可以用于定义泛指类型。
		
		2.因为可能会存在二义性，所以出现了typename。

		3.typename明确告诉编译器其后的标识符为类型。


	(2)try和catch新写法
		
		1.将函数体分为正常逻辑代码与异常处理代码2部分。
		
			int func()try
			{
				return i;
			}
			catch(...)
			{
				return -1;
			}

		2.函数定义和声明时可以直接制定可能抛出的异常声明。
		
			int func(int i) throw(int, char)
			{
				
			}

		注意事项：
		
			-函数声明异常后只能抛出声明的异常。
			-可直接通过异常声明定义无异常函数。 


