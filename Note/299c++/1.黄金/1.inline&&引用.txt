2.C++对比c的升级
	
	(1)更强调实用性，可在任意地方声明变量
	
	(2)register只是一个兼容作用
	
	(3)编译器能后更好地进行优化
	
	(4)任意标识符都必须显示地指明类型，防止二义性
	
		1.在C中：

			int f()表示返回值为int，接受任意参数的函数。
			f(void)表示返回值为int，无参函数。
			
		2.在c++中：
			
			int f()和int f(void)具有相同的意义，
			表示返回值为int的无参函数。C++中不允许默认类型。

3.c++中的const
	
	(1)回顾c中的const
		
		1.const不能定义真正意义上的常量。只有enum可以。

	(2)c++中的const
		
		1.用const修饰变量a时，编译器会将a的值放到符号表中。当a被调用时，就会直接在符号表中将值去出。

		2.对const常量使用了extern或&，编译器就会给对应常量分配空间。但调用对应变量时，也只会去符号表取值。

		3.所以c++中const定义的就是真正的常量。

	(3)const与宏的区别
		
		1.const常量是由编译器处理。编译器会对其进行类型和作用域的检查。
		
		2.宏定义由预处理器处理，只是单纯的文本替换，没有类型和作用域的概念。

4.布尔类型和引用
	
	(1)bool类型
	
		1.只有ture(1)和false(0)两种值，只占一个字节。
	
		2.如果给bool类型变量赋值非0的数，结果都为1,。

	(2)三目运算符		

		1.在c++中，三目运算符在所有可能返回值都是变量时，返回的是变量引用。所以有以下的效果：
				
			int a = 1;
			int b = 2;
			(a < b ? a : b) = 3;//等价于

	(3)引用
		
		1.语法：Type& name = var;普通引用在定义时必须用同类型的变量进行初始化。
				
			int a = 4;
			int& b = a; 
			
			b = a;	//操作b就是操作a
		
5.引用的本质
			
	(1)const引用	
	
		1.const引用让变量拥有只读属性:
		
			a = 0 ;
			const int& b = a;
			b = 5;//错误
		
		2.对于const引用变量，可以用常量进行赋值：
			
			const int& b = 1;
				
	(2)c++中引用的本质
		
		1.在c++编译器内部，是通过指针实现引用概念的。
		
		2.int& name引用的实质是:int* const name。
		
	(3)规则
		
		1.函数不能返回局部变量的引用。
			
6.内联函数
				
	(1)内联函数定义
		
		1.C++编译器内联编译一个函数，并将函数体插入函数调用的地方。
		
		2.inline关键字必须和函数定义在一起，编译器才会知道内联请求。编译器可以拒接内联请求。
		
		3.内联函数没有普通函数调用时的额外开销(压栈、跳转、返回)。

	(2)c++编译器
	
		1.现代c++编译器能够进行编译优化，一些函数即使没有inline声明，也可能被内联编译。

		2.一些现代c++编译器提供了扩展语法，能够对函数进行强制内联。语法位置加在函数前：	
			
			- g++：__attribute__((always_inline))属性
			- MSVC：__forceinline

	(3)c++中inline内联编译限制：
		
		1.不能存在任何形式的循环语句；不能存在过多条件判断语句；不能过于庞大。
		
		2.不能对函数进行取址操作；内联声明必须在调用之前。

		注意：
		现在许多先进的编译器会少一些限制。


