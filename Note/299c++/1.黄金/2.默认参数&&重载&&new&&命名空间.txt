7.函数参数的扩展
	
	(1)函数默认参数
		
		1.c++中可以在函数声明时为参数提供一个默认值。如果调用函数时没有提供参数，则使用默认值：
			
			int mul(int x = 0);

		2.如果函数有多个参数，在函数调用时，一个参数使用了默认值，它后面的参数也必须使用默认值。
		
			int add(int x, int y = 1, int z = 2)
			{
				return x + y + z;
			}
			
			add(0);此时x=0，y使用默认值，z也必须使用默认值。
			
		3.设计函数时，默认值要从最右的参数开始分配。因为参数赋值必须从左到右，不能空出一个。
			
	(2)函数的占位参数
		
		1.声明函数时占位参数只有参数类型声明，没有参数名声明。一般情况下，函数体内无法使用占位参数。
			
			int func(int x, int);
			
		2.主要为了兼容c语言。

8.函数重载分析1
			
	(1)重载(Overload)定义
		
		1.同一个标识符在不同的上下文有不同的意义。即同一个函数名定义不同的函数。
		
		2.函数重载是由函数名和参数列表决定的，与函数返回值无关。
		
		3.重载函数本质上是相互独立的不同函数。
		
	(2)函数重载条件
		
		1.至少满足一个：参数个数不同、参数类型不同、参数顺序不同。
		
		2.调用重载函数时编译器不允许有二义性。
		
	(2)编译器调用重载函数的准则
		
		1.将所有同名函数作为候选者。

		2.寻找可行候选者：精确匹配实参；通过默认参数能够匹配实参；通过默认类型转换匹配实参。
		
		3.如果以上都不可行，就会调用失败。

9.函数重载分析2
	
	(1)函数重载遇上函数指针的标准
		
		1.指针对应的重载函数的参数列表列表要与指针指向函数的参数类别一致。

		2.匹配候选者时重载函数类型要与函数指针的类型要一致。

	(2)c++和c代码的互相调用
		
		1.c++编译器会优先使用c++编译的方式。extern关键字能强制让c++编译器进行c方式编译。
			
			extern "C"
			{
				//括号内的内容用c方式编译 
			}

	(3)判断编译器：__cplusplus
		
		1.c++编译器内置的标准宏定义，可用来当前是什么编译器。可利用它写出两种编译器都可编译通过的函数：
			
			#ifdef __cplusplus
			extern "C"{
			#endif
			
			#include "xx.h"		
			
			#ifdef __cplusplus
			}
			#endif
			
	(4)关于c++重载的注意与分析
		
		1.c++编译器不能以c的方式编译重载函数。
		
		2.编译方式决定函数名被编译后在符号表中的目标名：
			
			c++编译方式是将函数名和参数列表编译成目标名。
			c编译方式只是将函数名直接作为目标名进行编译。

		3.所以c语言不支持函数重载。

10.c++新成员
	
	(1)c++中的动态内存分配
		
		1.通过new关键字进行动态内存申请;动态内存申请时基于类型进行的；delete关键字用于内存释放。

			变量申请：	Type* pointer = new Type;
						delete pointer;
			
			数组申请：	Type* pointer = new Type[N];
						delete[] pointer;

		2.动态分配内存一般比需要内存的多，如以下命令，p指向的内存空间为至少40字节。
			
			int *p = new int[10];

		3.new在申请单个类型变量时可进行初始化，malloc不具备内存初始化特性。申请内存后赋予内存括号中的值：
			
			int *pi = new int(1);
			float *pf = new float(2.0f);
			char *pc = new char('c');

	(2)c++中的命名空间
		
		1.命名空间定义
			
			namespace Name
			{
				namespace internal
				{
					//...
				}
				//...
			}
		
		2.使用命名空间
			
			使用整个命名空间		using namespace name;
			使用命名空间中的变量	using name::variable;
			使用默认命名空间中的变量::variable
		
		3.命名空间是为了用于解决c中的名称冲突问题。


