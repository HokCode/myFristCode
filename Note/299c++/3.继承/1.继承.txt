43.继承的概念和意义
	
	(1)类之间的组合关系特征
		
		1.将其他类的对象作为当前类的成员使用。
		
		2.当前类的对象与成员对象的生命期相同。
		
		3.成员对象在用法上与普通对象完全一致。

	(2)面向对象中的继承
		
		1.指类之间的父子类关系。
		
		2.子类拥有父类的所有属性和行为，是一种特殊的父类。
		
		3.子类对象可当作父类对象使用，也可添加父类没有的方法和属性。
		
		4.子类对象可以直接初始化或直接赋值给父类。

	(3)继承关系的描述
		
		class Parent
		{}

		class child : public Parent
		{}

	(4)继承的意义
		
		1.c++中代码复用的重要手段，通过继承可得到父类所有功能，还可添加新功能。
		
44.继承的访问级别
	
	(1)子类在父类的访问级别
	
		1.子类不能访问父类中private的数据。
		
	(2)protected关键字
		
		1.修饰的成员不能被外接直接访问，但可以被子类访问。

45.不同的继承方式
	
	(1)三种继承方式
		
		1.public继承：父类成员在子类成员中保持原有访问级别。
		
		2.private继承：父类成员在子类中变为私有成员。
		
		3.protected继承：父类中的公有成员变为保护成员，其他成员不变。

		4.private为默认继承方式。

	(2)常用继承
		
		1.c++工程项目一般只用public继承。

		2.protected和private的复杂性远大于实用性。

		3.D、C#、JAVA只支持public继承。

46.继承中的构造与析构
	
	(1)子类调用父类构造函数
		
		1.默认调用(隐式)：只适用于无参构造函数或使用默认参数的构造函数。
		
		2.显示调用：通过初始化列表进行调用，使用与所有父类构造函数。

			Child(string s) : Parent(s), mo1(s), mo2(s)
			{
				//..;
			}

	(2)构造规则
		
		1.子类对象在创建时会先调用父类的构造函数。
		
		2.父类构造函数可被隐式调用或显示调用。

	(3)对象创建时构造函数的调用顺序
		
		1.先调用父类的构造函数、再成员变量的构造函数、最后自己的构造函数。
		
		2.先父母、后客人(组合)、再自己。

		3.析构函数的调用顺序与构造顺序相反。

47.父子类之间的冲突
	
	(1)子类与父类的同名成员变量
		
		1.子类可以定义父类中的同名成员，并隐藏父类中的同名成员。
		
		2.父类中的同名成员依然存在于子类中。可通过作用域分辨符(::)访问父类中的同名成员。
			
			Child c;
			c.mi = 100;
			c.Paremt::mi = 100;

	(2)成员函数重载
		
		1.函数重载必须发生在同一作用域。

		2.子类的同名函数会覆盖父类的同名函数，所以两者不能构成重载关系。

		3.可通过作用域分辨符访问父类中的同名函数。

48.同名覆盖引发的问题
	
	(1)父类指针(引用)指向子类对象
		
		1.子类对象退化为父类对象，只能访问父类中定义的成员。
		
		2.可以直接访问父类中的同名成员。

	(2)子类对象
		
		1.子类对象可以当作父类对象使用。
		
		2.子类中可重写父类中的成员函数。


