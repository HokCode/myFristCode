4.4 
	1.指针数组与数组指针
		
		(1)定义
			指针数组：存储着指针的数组。
			数组指针：指向数组的指针变量。
		
		(2)分析表达式
			第一个：int *p[5]	：p是一个数组，数组中的元素是指针，指针指向的元素类型是int类型。指针数组。
			第二个：int (*p)[5]	：p是一个指针，指针指向一个数组，数组中的元素是int类型。数组指针。
			第三个：int *(p[5])	：与第一个同理。
			
			分析：[] 的优先级级比 * 高( [] 优先级是运算符之首)。级别高的先结合。逐层向外剥。
					
	2.	函数指针
		
		(1)定义
			1.实质就是指向函数的指针变量，它的值就是某个函数的地址(函数名在编译器中的值)。
			2.函数的实质就是一段在内存中连续分布的代码。函数中第一段代码的地址，就是函数地址。C语言中函数地址用函数名表示。
			
		(2)函数指针的书写和分析方法
			
			1.概念
				为了给编译器更多信息，C语言要区分指针变量类型(譬如：int *p,int (*p)[5])。
				
			2.函数指针写法
					譬如：  void func(void);
				
				对应写法：	void (*pfunc)(void);	//类型是void (*)(void)。pfunc是变量名，可以改。
							pfunc = func;		    //func是函数名，也就是函数的首地址，所以把它赋给函数指针。
							pfunc = &func;			//func做右值时与&func相同(与数组的巨大区别)。
				
				调用函数： 	pfunc();				
				
				实例函数
					strcpy函数: 	char *strcpy(char *dest, const char *src);
						
					对应函数指针：	char *(*pcpy)(char *,const char *);	
			
					#include<stdio.h>
					#include<string.h>
								
					int main(void)
					{
						char a[3];
						char *(*pcpy)(char *,const char *);
						pcpy = strcpy;
						pcpy(a,"abc");
						
						printf("a = %s.\n",a);
											
						return 0;
					}
		
			3.拓展(少用)：
					char *(*pTpye[5])(char *,const char *)	//函数指针数组。一个存放这若干指针的数组，数组中的指针是函数指针。
					
					char *((*(*pTpye))[5])(char *,const char *)
					//函数指针数组指针。一个指向一个数组的指针，数组中存放着指针，指针是函数指针。					
		
			4.typedef关键字
						
				(1)定义
					用来定义(重命名)类型。
						
				(2)C语言中类型一共有2种:
					1.编译器定义的原生类型(int,char,double)。
					2.用户自定义的类型，程序员自己定义的。		
				
				(3) 生产类型：有时候定义类型太长了，为了让定义更简洁，可以用typedef给它重命名。
							
					譬如：	
								
						typedef	char *(*pTpye)(char *,const char *)
							
					分析：重命名了一种类型，这种新类型的名字叫pTpye,类型是：char *(*)(char *,const char *)。
							
					定义： pType p1;  //等效于char *(*p1)(char *,const char *)
					
					实例代码:
						#include<stdio.h>
						#include<string.h>
						typedef char *(*pType)(char *,const char *);	//重命名

						int main(void)
						{
							char a[3];

							pType p1; 
							p1 = strcpy;
							p1(a,"abc");
							
							printf("a = %s.\n",a);
												
							return 0;
						}

						
	
	3. 函数指针实战1
		
		(1)通过用函数指针调用不同函数，得到不同结果。
			
			譬如：加减乘除简单计算机函数。
				
			总结：实现了面向对象三大特征之一多态：同一个执行过程实际结果不一样(c++,java)。
			
			反省：	
				1.序出现错误时，先定位错误，在可以处打印信息来锁定错误语句，最后再分析。
				2.Linux命令行默认是行缓冲，printf输出时，Linux会将其缓冲起来放在缓冲区等整行准备好再一次性输出。所以使用printf时，最后要加回车"\n"。
				
				3.关于scanf。最后的回车"\n"不会被scanf接收，会残留在输入缓冲区中。
		
	4.用结构体内嵌指针实现分层结构	
		
		(1)程序为什么要分层，因为复杂程序东西太多一个人搞不定，需要更多人协同完成，分工合作。最后再彼此调用组合共同工作。
		
		程序例子：
				设计一个2层的计算器。
				上层是framework.c，实现应用程序框架
				下层是cal.c，实现计算器
				
		实际工作时cal.c是直接完成工作的，但是cal.c中的关键部分是调用frameworl.c中的函数来完成的。		
				
			1.先由一人写framework.c， framework.c中需要完成计算器的业务逻辑(功能)，并把相应的接口写在对应头文件(cal.h)中。	
			
			2.另一个人来完成cal.c，完成具体计算器，需要framework.c的头文件(cal.h)。		
			
		总结：
			(1)对于复杂的问题，用分层代码来解决会更加好。有多个层次结合来完成任务，每个层次专注各自不同的领域，不同层次之间用头文件来交互。
			(2)分层之后上层为下层提供服务，上层写的代码被下层调用。(framework.c为上层，cal.c为下层调用其calculator函数)
			
			(3)上层注重业务逻辑(要实现的功能)，与要实现的目标直接关联，但没有具体干活的函数。
			  
			(4)下层注重实际干活的函数，注重为上层填充变量，并且将变量传递给上层的函数(调用上层提供的接口函数)来完成任务。
			
			(5)下层代码中核心是一个结构体变量(struct cal)。
				
				逻辑：
				第一步：定义结构体变量。
				第二步：填充结构体变量。
				第三步：调用上层的接口函数，把结构体变量传给它。	
				（linux驱动架构，内核框架提供上层，程序员移植代码就是下层。)
		
	5. typedef深度讲解
		
		(1)内建类型ADT、自定义类型UDT。
		
		(2)typedef重命名类型而不是变量
			
			1.类型是一个数据模板，变量是一个实在的数据。类型是不占内存的，而变量是占内存的。
			
		(3)	typedef与结构体
			
			1.定义结构体。
				typedef struct student
				{
					char name[20];
					int age;
				}stu;
			
			那么定义结构体时，可以
				
				stu s1;		//效果与struct student s1相同

			2.结构体指针
				
				struct student *p1;		//结构体指针	
				stu *p2;				//同上
				
				另一种方法：
					
				typedef struct teacher
				{
					char name[20];
					char age;
				}teacher,*Pteacher;
				
				struct teacher *p1;		//定义结构体指针。
				Pteacher p2;			//便捷方式定义。用 Pteacher 代替 struct teacher *。

		(4)typedef与const
			
				typedef int *PINT;	//重命名int *类型为PINT。
			
			1.陷阱
				const PINT p1;		//并非等价于 const int *; 而是等价于 int *const p1; 		
				
				PINT const p2;		//同上，依然等价于 int *const p2

			2.方法
				如果想得到const int *p 这种效果：
				
				typedef const int *CPINT;	//
				CPINT p1;					//等价于 const int *p1;
				
		(5)typedef重要意义
			
			1.简化类型的描述。
				例：char Func(char , const char);
			重命名：char (*p1)(char, const char);
			
			2.很多编程体系下，人们倾向于不适用int、double等C语言内建类型，便于日后修改。

	
	6.二重指针
		
		(1)二重指针与普通一重指针的区别。
			
			int a = 0;
			char **p1;	//二重指针。
			char *p2;	//一重指针。
			
			二重指针和一重指针的本质都是指针变量。都是占4个字节。
			
			p2 = &a;	//char *(一重指针)指向的变量是char类型的。
			p1 = p2;	//char **(二重指针)指向的变量是char *类型。		
			p1 = &p2;	//p2本来是char *类型，加&后就变成了char **类型。
		
		(2)二重指针的用法
			
			1.二重指针指向一重指针的地址。
			
				参考第(1)点。
			
			2.二重指针指向指针数组(常用用法)
				
				int *p1[5];
				int *p2;
				int **p3;
				
				p2 = p1;	//
				
				p3 = p1;	//p1是数组名，做右值时表示数组首元素的首地址。数组的元素是int *类型(一重指针)，所以p1就是指针的指针，就是一个int **类型(二重指针)。
			
			3.函数传参时，为了通过函数内部改变外部的一个指针变量，会传这个指针变量的地址(二重指针)进去。
			
				void func(int **p)
				{
					*p = 0x12345678;	//通过func函数改变实参(一个指针)指向的地址。
				}
			
		(3)二重指针与数组指针
			
			1.两者与结构体指针、一重指针的本质都相同，都是指针变量。只是不同类型指针指向的类型不同。
			
			2.二重指针就是：指针数组指针(指向指针数组的指针)。
			
	7.二维数组
		
		(1)存储方式：从内存角度看，二维数组与一维数组相同。
			
		(2)二维数组好处：好理解、代码好写、好组织。	

		(3)二维数组的应用与更多维数组
			
			1.例子：两组学生共10个人看成绩。用a[2][5]比用b[10]清晰。
			
			2.数学运算：平面直角坐标系。
			
			3.三维数组：立体空间。
			  四维空间：四轴飞行器。
			
		(4)哪个是第一维，哪个是第二维。
			
			1.二维数组 int a[2][5]，2是第一维，5是第二维。			
			
			结合内存理解：
				最外面一层是数组是第一维，所以int这个数组a[2][5]有2个元素；其中每一个元素又是含有5个元素的一维数组(这就是第二维)。
			
		(3)二维数组的下标式访问和指针式访问
					
			1.例：	
					int a[2][5]，(合适类型的)p = a;	
					a[0][0]等同于*(*(p+0)+0);
					a[i][j]等同于*(*(p+i)+j);
					
	8.二维数组的运算和指针
		
		(1)指针指向二维数组的数组名(数组指针)
		
			定义指针
				int a[2][5];	//a是二维数组的数组名，做右值表示二维数组第一维数组的首元素首地址，等同于&a[0]。			
				int (*p)[5];	//数组指针，指针指向一个数组，数组有5个int类型的元素。类型匹配。
		
			用指针p指向数组a
				p = a;
				p = &a[0];
				
			用指针p访问数组a
				*(*(p + 0) + 0)	//相当于a[0][0].
		
		
		(2)指针指向二维数组的第一维
			
			定义指针
				int *p1 = a[0];	//表示二维数组的第一维的第一个元素，相当于是第二维的首元素首地址，等同于&a[0][0]。		
				int *p2 = a[1];	//与上类似，等同于&a[1][0]。
			
			用指针p访问数组a
				*(p1 + 3)		//相当于a[0][3].
				*(p2 + 1)		//相当于a[1][1].
		
		(3)指针指向二维数组的第二维
		
			理论上是不行的，因为二维元素已经是普通变量了。除非用&。
			
			定义指针
				int *p = &a[i][j];
			
		总结：
			1.弄清楚数组中各个符号的含义。
			2.数组(特别是二维数组)的指针访问。
		
						
		
		
		
		
		
		
		
			
			
			
			
			