4.1.1.1、代码与数据

	计算机都是用来计算数据。
	计算机程序=代码+数据。
	代码就是动作，用来加工数据。计算机运行完得到一个结果。
	例：一个函数，函数的形参就是待加工的数据（函数内还需要一些临时数据，就是局部变量），函数本体就是代码，函数的返回值就是结果。函数体的执行过程就是过程。

	int add(int a, int b)
	{
		return a+b;//这个函数的执行就是为了得到结果
	}

	void add(int a, int b)
	{
		int c;
		c=a + b;
		printf("a + b = %d",c);//这个函数的执行重在过程，不需要返回值。
	}

	int add(int a, int b)
	{
		int c;
		c = a + b;
		return c;/这个函数又重结果又重过程。
	}

4.1.1.2、计算机程序运行过程
	
	计算机程序运行的过程，其实就是程序中很多个函数相继运行的过程。程序的本质就是函数，函数的本质是加工数据的动作。

4.1.1.3、冯诺依曼结构和哈佛结构

	冯诺依曼结构：数据和代码放在一起。（S5PV210）
	哈佛结构：数据和代码分开存放。（单片机）
	什么是代码：函数。
	什么是数据：全局变量、局部变量。
	
4.1.1.4、动态内存DRAM和静态内存SRAM
	
	DRAM是动态内存，SRAM是静态内存。
	
4.1.1.5、为什么需要内存
	内存是用来储存可变数据的，数据在程序中表现为全局变量、局部变量等（在gcc中，其实常量也是存储在内存中的）（大部分单片机中，常量是存储在flash中的，也就是代码段）。

4.1.1.6、如何管理内存
	
	写程序时应该懂得如何妥善管理内此乃，避免造成程序运行消耗过多的内存。
	从操作系统角度：操作系统掌握所有的硬件内存。因为内存很大，所以操作系统把内存分成一个个的页面（其实就是一块块，每块4KB），然后以页面为单位管理。页面内以字节为单位进行管理。我们只需用API即可管理内存。如：在C语言中使用malloc（申请内存）、 free（释放内存）这些接口来管理内存。在c++语言中使用new和delete。（如果忘记free和delete，会造成内存泄漏）。 
	
	没有操作系统，裸机程序中，程序需要直接操作内存，编程者需要自己计算内存的使用和安排。 
	
	从语言的角度讲： 不同语言提供了不同的操作内存接口。
	
	比如汇编：没有内存管理，靠程序员自己管理内存。汇编操作内存时直接使用内存地址，较麻烦。	      
	比如C语言：编译器帮我们管理直接内存地址，我们通过编译器提供的变量名来访问内存。可以通过API（参考上面）来访问系统。如果裸机程序中需要大块的内存，则需要自己定义数组等来解决。
	
4.1.3	内存的理解
	从硬件角度讲：如电脑的内存条。SRAM（静态内存）和DRAM（动态内存）。SRAM不需要初始化就能使用，DRAM需要初始化才能使用。

	从逻辑角度讲：内存是一个可以随机访问的东西，只要给一个地址，就可以访问内存地址，并且可以读写（逻辑上也可以限制其为只读或只写）。内存在编程中天然是用来存放变量的。 
	有了内存，c语言才能定义变量，c语言中的一个变量实际就是对应内存中一个单元。

	内存的编程模型
	从逻辑角度讲，内存实际是由无限内存单元格组成的，每个单元格有一个固定的地址叫内存地址。这个内存地址和这个内存单元格唯一对应而且永久绑定。
		
	现实中实际的内存是有限制的，如32位系统，内存限制为4G。实际上32位的系统中的内存小于或等于4G。	  
	
	内存位宽
		从硬件角度：硬件内存的实现本身是有宽度的，如：有些是8位的，有些是16位的。内存芯片之间是可以并联的，通过并联后即使8位的内存芯片也可以做出16位或32位的硬件内存。
		
		从逻辑上讲:内存位宽是任意的，如：24位的内存（但实际上是买不到的）。所以实际很多操作都是受限于硬件的特性的。
	
	位和字节			
		内存单元的大小单位有4个：位（1bit） 字节（8bit） 半字（一般是16bit） 字（一般是32bit）。位和字节在所有机器和计算机中（16、32、64系统）都是一样大小。

	字和半字
		历史上曾被混乱定义过。字、半字、双字具体有多少位是依赖于平台。
		在linux+ARM这个软硬件平台上，字是32位的。

4.1.4	内存的编址方法
	
		内存单元的2个概念：地址和空间。内存在逻辑上是一个个格子，这些格子用来装东西（内存中储存的数），每个格子有一个编号，这个编号就是内存地址。这个内存地址（一个数字）和这个格子空间一一对应且永久绑定。
		
	内存的编址是以字节为单位的
	
		随便给一个内存地址，这个内存地址对应的空间就是一个字节（8bit），是固定的。
		
	内存和数据类型的关系
		
		C语言中基本的数据类型有:char short int long float double
		
		int 整形（这个整体现在它和CPU本身的数据位宽是一样的）譬如32位CPU里面，整形就是32位，int 就是32位。
		数据类型是用来定义变量的，这些变量需要在内存中存储、运算。所以数据类型必须和类型相匹配，否则会影响工作效率。
		在32位系统定义变量最好用int，效率最高。原因在于32位的系统本身配合内存等也是32位。定位8位char类型变量和16位short类型变量的话效率不高。
		例子：在很多32位环境下，实际定义bool类型（实际只需要1个bit就够了），都是用int实现的。定义时，编译器实际帮我们分配了32位的内存来储存这个bool变量，浪费内存但是效率高。
		
	内存对齐
		在C中int a，在内存中必须分配4个字节来存储这个a。
		第一种：0 1 2 3 						对齐访问
		第二种：1 2 3 4 或 2 3 4 5 或 3 4 5 6 	非对齐访问
		
		从硬件角度来说，32位的内存中 0 1 2 3四个单元本身逻辑上就有相关性。这4个字节组合起来当作一个int（对齐访问），硬件上就是合适的，这样效率就会高。
		
4.1.5	C语言如何操作内存
		C对内存地址进行封装（用变量名来访问内存、数据类型的含义、函数名的含义）
		如：int a； //编译器帮我们申请了1个int类型的内存格子（长度是4字节），并且把a和这个格子绑定。
		当编译 a = 5； //编译器发现我们给a赋值，就会把5这个值丢到符号绑定的那个内存格子。
		
		当编译
		a += 4；//编译器发现我们要给a加值，会先把a原来的值读出来，把这个值加4，再把加之后的和写入a里面去。
		
		C中数据类型的本质：表示一个内存格子的长度和解析方法。
		
			数据类型解析方法含义：譬如我有一个内存地址（0x30000000），我们可以通过给这个内存地址不同的类型来指定这个内存格子中二进制数的解析方法。
			如：int（0x30000000）:含义就是（0x30000000+0x30000001+0x3000000002+0x300000003）这4个字节连接起来共同存储的是一个int数据。	
			如：float（0x30000000）:含义就是（0x30000000+0x30000001+0x3000000002+0x300000003）这4个字节连接起来共同存储的是一个float数据。
			
			存放的空间相同，数值相同。但是解析的方法不一样（因为其存储的方式不一样）。
		
		C中函数就是一段代码的封装，函数名的本质就是这一段代码的首地址。
	
	指针
		指针的全名叫做指针变量，和普通变量没有任何区别。譬如：int a 和 int *p没有任何区别。只是解析方法  
		不一样。
	
	数组
		数组管理内存和普通变量没有本质区别。只是符号的解析方法不同。
		
		int a;		//编译器分配4字节长度给a，并且把首地址和符号a绑定起来。    
		int b[10]； //编译器分配40字节长度给b，并且把首地址和符号b绑定起来。
		数组中第一个元素成为首元素，每一个元素长度都是4，其中第一个字节的地址就称为首地址。
		
4.1.6	内存管理之结构体
		
	数据结构
		数据结构就是研究数据如何组织（在内存中排布），如何加工。
	
	最简单的数据结构
		
		数组
		
			优势：结构简单，可以通过下标随机访问。
			劣势：1. 数组中元素类型必须相同；2. 数组大小必须定义时给出，一旦确定就不能再随意改。
			
			为什么可以通过下标访问每个元素呢?
			因为同一个数组内元素类型相同。比如int a[5]; a[0]到a[2]之间相差8个字节。
		
		
		
		结构体
		
			Struct S
			{
				int a;
				char b;
			}；
			通过S.a、s.b访问各元素。
		
			
			结构体内嵌指针实现面向对象
		
			非面向对象的语言，不一定不能实现面向对象的代码。只是C++、JAVA等面向对象的语言实现面向对象简单一些。
			譬如：
			
			struct s
			{
				int age;			//普通变量
				void (*pfunc)(void) //函数指针，指向void func(void) 这类的函数
			
			}；
		
			这样包含了函数指针的结构体就类似于面向对象中的class。其中的函数指针就类似于class中的函数方法。
	
4.1.7	内存管理之栈（stack）
		
	栈：一种C语言的数据结构，用来保存局部变量。用来发明管理内存的。
	
	特点：自动分配小内存。先进后出 FILO（first in last off）（与之对应：队 先进先出 FIFO）
	
	底指针（buttom）：始终指向栈的开始。
	顶指针（top）	：可以上下移动（顶指针与底指针指向同一位置时，栈为空）。
	
	C语言中的局部变量使用栈来实现的。
	我们在C中定义一个局部变量时（int a），编译器会在栈中分配一段空间给这个局部变量（分配时栈顶指针会移动给出空间，将4字节（int）的栈内存地址和定义的局部变量关联起来，栈的操作是入栈。
	
	C语言实现局部变量初始化（int a=15；）的手段：
		int a;	//局部变量定义
		a = 15;	//普通的赋值语句。
	栈指针移动和内存分配都是自动的，函数退出时，栈的操作是自动弹栈（出栈），空间释放。
	
	栈内存管理的优点：分配和最后的回收都是自动的。
	栈内存管理的缺点：栈的内存不灵活，不好设置，太小怕溢出，太大怕浪费内存（类似数组）。所以在C中定义局部变量不能太大。
	
4.1.8 内存管理之堆（heap）	
	
	堆是一种内存管理方式。
	
	自由（随时申请、释放，大小随意）。堆内存是操作系统划归给堆管理器（操作系统的一段代码，属于操作系统的内存管理单元）管理的，然后向使用者提供API（malloc和free）来使用堆内存。
	
	什么时候使用：内存容量需求比较大时，需要反复使用及释放时。
	
	特点一：容量不限（常规使用的需求容量都能满足）。
	特点二：申请及释放都需要程序员写代码明确进行。如果程序员申请内存并使用后未释放，就会放生内存泄露。
	
	堆内存释放：直接调用free释放。 void free(void *prt)
	堆内存申请：有3个可选择的类似功能的函数：malloc,calloc,realloc.
	void *malloc(size_t size);
	void *calloc(size_t nmemb(单位), size_t size(多少)); // nmemb个单元，每个单元size个字节
	void *realloc(void *prt, size_t size);				 //改变原来申请的空间的大小
	
	譬如要申请10个int元素的内存：
	malloc(10*sizeof(int));  //如果元素为32位系统的int类型的话可以写成 malloc(10*4);
	calloc(10,sizeof(int));	 //如果元素为32位系统的int类型的话可以写成 calloc(10,4));	
	
	优点：灵活。
	劣势，需要程序员处理各种细节，依赖程序员水平，
	
4.1.9 复杂数据结构
	
	链表（双链表）
	
	哈希表（散列表）
	类似数组，但是下标（Key）是乱的没规律、散乱的。Key通过一条复杂公式计算，用于存和取。
	
	