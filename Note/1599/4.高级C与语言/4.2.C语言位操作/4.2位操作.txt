4.2.1 位操作符

位与    &   //同1才取1。
位或    |   //有1就取1。
位取反  ~   //1变成0，0变成1。
位异或  ^   //不同才取1，相同取0（少用）。（相异就或操作起来）
左移位  <<  //对于无符号数，左移时右侧补0
			//对于有符号数，左移时右侧补0	

右移位  >>  //对于无符号数，右移时右侧补0
			//对于有符号数，右移时右侧补符号位。（正数补0，负数补1）

4.2.2 位与、位或、位异或在操作寄存器时的特殊作用

	1.寄存器操作		
		（1）ARM是内存与IO统一编址的，ARM中有很多内部外设，SoC中CPU通过向这些内部外设的寄存器写入一些特定的值来操控这个内部外设，进而操控硬件动作。所以说：读写寄存器就是操控硬件。
		
		（2）寄存器的特点就是按位进行规划和使用。寄存器的读写是整体32位一起进行的。
		
		（3）寄存器操作的要求：在设定特定位时不影响其他位。
	
		（4）读-改-写理念：当想改变一个寄存器中某些待定位时，应先独处寄存器整体原来的值，然后在这个基础上修改我想要修改的待定位，再将修改后的值整体写入寄存器。这样就可以在不影响其他位值的情况下，修改自己想要修改的位的值。

	2.特定位清零用 位与&
		
		（1）位与操作特点：与1位与没变化，与0位与变成0。	
		譬如：如果想将寄存器某些特定位变成0而不变成其他位，可以构造合适的1和0组成的数和这个寄存器的值进行位与操作。
		假设32位寄存器:0xAAAAAAAA & 0xFFFF00FF,就可以吧bit8~bit15清0。
		
	3.特定位置1用 位或|
		
		（1）位或操作特点：与1位或变成1，与0位或无变化。
		譬如：如果想将寄存器某些特定位变成1而不变成其他位，可以构造合适的1和0组成的数和这个寄存器的值进行位或操作。


	4.特定位取反用 位异或^
	
		（1）位异或操作特点：与1位异或会取反，与0位异或无变化。
		譬如：如果想将寄存器某些特定位变成1而不变成其他位，可以构造合适的1和0组成的数和这个寄存器的值进行位异或操作。

4.2.3 如何用位运算构建特定的二进制数
		
	1.寄存器位操作经常需要特定位给特定值
		
		（1）赋特定值前要事先构建一个特别的数，这个数再和原来的值进行位操作（位与、位或、位异或）。
		
		（2）解法1：用工具或自己算。但是这样会变得依赖工具，读程序的人不容易理解。
			 解法2：写代码用位操作符号（移位和位取反）来构建特定的二进制数。
			
	2.使用移位获取特定位为1的二进制数
					 
			 譬如:
			（1）需要的数是一个bit3~bit7为1(隐含意思就是其他位为零)的二进制数。
				 相当于bit0(3 - 3)~bit4(7 - 3)为1（其他位都为零）的数左移3位。
				 方法：0x1f << 3。
			
			（2）需要的数是一个bit3~bit7、bit23~bit25同时为1（隐含意思就是其他位为零）的二进制数。
				 方法：	0x1f << 3 | 0x07 << 23。
		
	3.再结合位取反获取特定位为0的二进制数
		
			譬如：
			
			（1）需要的数是一个bit4~bit10为0，其余位全为1的数。
				 
				 旧方法：(0x0f << 0) | (0x1fffff<<11)  //连续为1的位数太多，数太难构造。
				 
				 新方法：~(0x7f << 4)                      //左移结合位取反
			 
	4.总结
		(1)如果要构造的数1少0多，则可以通过连续多个1左移n位得到。
		(2)如果要构造的数1多0少，则可以通过先构造其位反数，最后再取反。
		
		(3)如果想要的数连续1(连续0)的部分不止1个，则可以通过多段分别构造，再位或运算。因为参与位或运算的各个数为1的位是不重复的，所以这时的位或相当于几个数的叠加。
			 
			 
4.2.6 用宏定义来完成位运算

		例：直接用宏定义来置位、复位（最右边为第1位）。			
			
			(1)用宏定义将某一位 置1或清0.
		
			#define SET_BIT(x,n) (x | (1U<<(n-1)))	   //将第n位置1。1U意思是无符号1.			  
			#define CLEAR_BIT(x,n)	(x & ~(1U<<(n-1))) //将第n位清0。
			 
			(2)用宏定义连续将几位 置1或清0.
			
			#define SET_BIT_N_M(x, n, m) (x | (~(~(0U)<<(m-n+1))<<(n-1))         //置1。 
			#define CLEAR_BIT_N_M(x, n, m) (x & ~(~(~(0U)<<(m-n+1))<<(n-1)) 	 //清0。
			 
			(3)用宏定义读取多位数据.
			
			#define READ_BIT_N_M(x, n, m) ((x & (~(~(0U)<<(m-n+1))<<(n-1)))>>(n-1))        
			
			 
			 
			 
			 
			 ~(~(0U)<<(m-n+1))<<(n-1)







