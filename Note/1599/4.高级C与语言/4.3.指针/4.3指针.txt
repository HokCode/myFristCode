4.3 1.指针
		(1)指针实质就是一个变量，全名为指针变量，简称指针。
		
			指针的标准使用方式：
		
				int *p;int a = 4;      //定义指针变量
				
				p = &a;                //实现指针绑定，让P指向变量a。
				p = (int *)4;          //实现指针绑定，让p指向内存地址为4的那个变量。
				
				*p = 666;			   //解引用p，把值666放入p指向的变量中。
		
	2.指针带来的一些符号的理解
			
			星号*
				
			取地址符&
		
			指针定义并初始化、与指针定义然后赋值的区别.
			
		(1)左值与右值
			
			1.赋值运算符“=”左边的叫左值，右边的叫右值。
			2.当一个变量做左值时，编译器认为这个变量符号的真实含义是这个变量所对应的那个内存空间。
			  当一个变量做右值时，编译器认为这个变量符号的真实含义是这个变量所对应的内存空间中存储的那个数。
		
	3.野指针
			
			1.定义：野指针指向的位置是不可知的（随机的、不正确的、没有明确的）。
			
			例：			
			#include <stdio.h>
			{
				int *p;
				*p = 4;			//没有与某个空间绑定，不可以解引用。
				return 0;
			}
		
			2.野指针指向的不可预知的地址有3种情况。
				
				1.指向不可访问的地址(操作系统不允许访问的敏感地址，譬如内核空间)，导致程序段错误。
				
				2.指向一个可用的、而且没什么意义的空间(曾使用过的已经不用的栈空间或堆空间)，这时程序运行不会报错。但是程序其实是有问题的。
				
				3.指向一个可用空间，这个空间其实在程序中正在被使用(譬如是程序的一个变量x)，那么野指针的解引用会修改了变量x的值，导致系统崩溃，数据损害。(最大危害)
		
			3.如何避免野指针
				
				1.在指针的解引用之前确保指针指向一个绝对可用的空间。
			
				2.定义指针时，同时初始化为NULL。
				  解引用前先去判断指针是不是NULL。
				  指针使用完后，将其赋值为NULL。
				  在使用指针之前，将其赋值绑定给一个可用地址空间。
				
				#include <stdio.h>
			{
				int a;
				int *p = NULL;
				//省略400行代码。。。
				
				p = &a;
				
				if(NULL != p)
				{
					*p = 4;	//解引用前判定指针是否指着NULL；
				}
				p = NULL;
				return 0;
			}
			
			
			4.NULL的定义
				
				NULL在C/C++中定义为：
					
					#ifdef _cplusplus         //定义这个符号就表示当前是C++环境
					#define NULL 0
					#else
					#define NULL (void *)0    //在C中强制类型转换为void *的0
					#endif
				
				NULL的实质其实就是0，给指针赋初值时，就是让指针指向0地址处。
	
	4.const关键词与指针
		
		1.const关键词在C语言中用来修饰变量，表示这个变量是常量。

		2.const修饰指针的4个形式
			
			第一种：const int *p		    //p不是const，p指向的变量是const
			
			第二种：int const *p		    //p不是const，p指向的变量是const	
			
			第三种：int * const p		    //p是const，p指向的变量不是const
			
			第四种：const int * const p		//p和p指向的变量都是const
				
		3.如何修改const类型数据	
			
			(1)利用指针修改。
			
				#include<stdio.h>
				
				int main(void)
				{
					
					const int a = 5;
					int *p;
					p = (int *)&a;      //通过强制类型警告来消除报错。
					*p = 6;					
				}
				
			(2)在某些单片机环境下，const修饰的变量是不可以改的。const修饰的变量到底能不能真的被修改，取决于具体的环境。
				
			(3)const是通过编译器在编译的时候执行检查来确保实现的(也就是说const类型的变量不能改是编译错误，不是运行时的错误)。所以像(1)中骗过编译器，就可以修改const定义的变量。
				
		4.什么情况下使用const
			
			(1)当变量不需要被修改时。
				
				
	5.数组
		
		(1)分开定义多个变量(int a, b, c, d;)和定义一个数组(int a[4];)的区别:
		   单独定义时变量在内存中的地址不一定相连，但是定义成数组后，数组中的4个元素地址是肯定依次相连的。
				
		(2)数组中多个变量必须单独访问，但是因为他们的地址彼此相连，因此很适合用指针来操作。
		
		
		(3)数组中几个关键符号理解。(譬如:int a[4]. a a[0] &a &a[0])
			
			1.清楚左值右值的含义。
			2.数组(除了在初始化时候)不能做左值，不能直接用赋值符号赋值。a做右值时，表示的是a首元素的地址(等同与a[0])。
			
			3.&a就是数组名a取地址，字面意思来看就应该是数组的地址。&a不能做左值(&a实质是一个常量)。
				
				为什么是常量：
				因为数组是编译器在内存中自动分配的。每次运行程序编译器都会分配一块内存给这个数组，完成分配后，数组的地址就定好了，无法再改了。
			
			4.&a和a做右值时的区别：
			&a是整个数组的首地址，a是首元素的首地址。它们在数值上是相等的，但是意义不相同，导致在参与运算时有不同的表现。	
		
			5.&a[0]([]的优先级比&高)
			做左值时表示数组首元素对应的空间。
			做右值时表示数组首元素对应的内存空间中存储的那个值，等同与a。
		
	6.指针与数组
		
		(1)以指针方式来访问数组元素
			
			1.数组元素使用时只能单个访问。访问方式有2种：数组形式和指针形式。
		
			2.数组格式访问数组元素是：数组名[下标]；(下标从0开始)
		
			3.指针格式访问数组元素是:*(指针 + 偏移量)；指针可以不是首元素地址。
			4.数组下标方式和指针方式均可访问数组元素，两者的实质是一样的。编译器内部是用指针方式访问数组元素的，数组下标的方式只是编译器提供给编译者的一种壳。所以说指针方式来访问数组才是本质的做法。
		
		(2)	从内存角度理解指针访问数组的实质
			1.数组特点：数组中各个元素的地址是依次相连的。数组中各个元素的类型都是相同的。所以数组中的元素其实就是地址相连接、占地大小相同的一串内存空间。也决定了只要知道数组中一个元素的地址，就可以推算出其他元素的地址。
			
		(3) 指针和数组类型的匹配问题
				
				指针类型要与数组类型相同。
				
				(1)int *p, int a[5]; p = a;			//类型匹配
				(2)int *p, int a[5]; p = &a;		//类型不匹配，p是int类型，&a是数组指针类型。	
				(3)&a、a、&a[0]从数值上看是完全相等的。
							   从意义上看&a[0]和a都表示首元素的首地址。而&a是整个数组的首地址。
							   从类型看，a和&a[0]是元素指针，即int *类型。而&a是数组指针，即int (*)[]类型。
					
		(4)指针类型决定了指针如何参与运算
			
			(1)指针运算即是地址运算。
			(2)指针变量+1，代表加1*sizeof(指针类型)。
				如：指针类型为int，则+4。
					指针类型为char，则+1。
		
	7.指针与强制类型转换
		
		(1)变量的数据类型
			
			1.不同数据类型解析数据方式不同。(int和float)
			
			2.int、char、short等属于整形，存储方式相同(数转换 成二进制往内存中放)。float和double彼此不同，和整形更不同。
			C语言中的数据类型的本质，就是决定了这个数在内存中怎么存储的问题。也是决定了这个数如何转成二进制的问题。
			
			*按照int类型存却按照float类型取			一定出错
			*按照float类型存却按照double类型取		一定出错
			*按照int类型存却按照char类型取			可能出错
			*按照short类型存却按照int类型取			可能出错
		
		(3)指针的数据类型
			
			1.指针本质：变量，指针就是指针变量。
			
			2.一个指针(int *p)涉及2个变量：一个是指针变量本身(p)，另一个指的是指针指向的那个变量(*p)。
		
			3.int *类型就是指针类型，只要是指针类型都是占4个字节。
			  解析方式都是按照地址的方式来解析(意思是里面存的32个二进制数加起来表示一个内存地址)。
			  所有的指针类型(int *, char *, double *)的解析方式都相同。
			4.对于指针所指向的那个变量来说，指针的类型是很重要的(int*指针类型所指的变量就是int类型)。指针变量的类型是为了它所指的变量，决定了指针所指变量如何存储，如何解析。
		
		(4)	指针的类型转换
		
			1.实例1(int * -> float *)
				分析：int和float的解析方式不兼容，所以转换后再访问绝地出错。
			
			2.实例2(int * -> char *)
				
				分析：int和char类型都是整形，是兼容的。可能出错。因为int有4个字节，char只有1个字节，所以int的范围比char大。在char范围之类，才可以互转。同理，char转int不会出错。
				
			3.实例3(int * -> short *)
				
				分析:参考实例2。
		
		
	8.指针、数组与sizeof运算符
		
		(1)sizeof
			1.sizeof是c语言的一个运算符(不是函数)，用来返回小括号里面变量或者数据类型占用的字节数。
		
			2.用于返回当前变量/数据类型在当前环境平台下占几个字节。
		
			3.sizeof与strlen的区别。
				
				例：
				int main(void)
				{
					char str[] = {1, 2, 3};
					
					printf("sizeof = %d",sizeof(str));   //sizeof返回的是结果为4。					printf("strlen = %d",strlen(str));	 //strlen返回的是字符串本身长度不包含(\0)，结果为3。
					return 0;							
				}
			
				拓展：
				int main(void)
				{
					char str[] = {1, 2, 3};
					char *p = str;
					printf("sizeof = %d",sizeof(p));     //32位系统中所有指针变量大小都为4。					
					printf("sizeof = %d",sizeof(*p));	 //相当于sizeof(char)，结果为1;	 
					printf("strlen = %d",strlen(str));	 //相当于strlen(str)，结果为4;
					return 0;							
				}
		
			4.函数传参，形参是可以用数组的。但是实际传递的不是整个数组，而是数组的首元素首地址，相当于传递的是指向数组首元素首地址的指针。
				
				例：
					void func(int a[])
					{
						printf("%d",sizeof(a));
					}
		
					void func1(int *a)
					{
						printf("%d",sizeof(a));
					}
		
				两者意义相同。
		
			5.#define、typedef
				
				区别：
					#define dpchar char *	//用dpchar表示char *
					typedef char * tpchar	//把 "char *" 重命名为 "tpchar" ,用于用户自定义类型。
					
					例：
					
					#define <stdio.h>
					#define dpchar char *
					typedef char * tpchar;
					
					int main(void)
					{
						dpchar p1, p2;	//展开：char *p1,p2;相当于char *p1,char p2;
						tpchar p3, p4;	//等价：char *p3,char *p4;
						return 0;
					}
				
	9.函数传参
	
		(1)普通变量作为函数形参
			1.形参和实参名字可以相同，也可以不同。实际上是用实参代替所对应的形参。
			2.在子函数内部，形参的值等于实参。
			3.这就是"传值调用"(相当于形参做左值、实参做右值)。
			
		(2)数组作为函数形参	
		
			1.数组传参时，实际传的是数组首元素的首地址(参考第8节第4点)。所以在子函数内部，传进来的数组名等于是一个指向数组首元素首地址的指针。
			2.在子函数内传参得到的数组首元素首地址，和数组本身首元素首地址的地址相同。("传址调用"，调用子函数时传了地址"指针"，此时就可以通过地址来访问实参)。
		
			3.数组作为函数形参时，[]里的数字是可有可无的。因为数组做形参传递的只是指针，没有数组长度这个信息。
		
		(3)指针作为函数形参
			
			与第2点类似。
		
		(4)结构体作为函数形参
			
			1.结构体传参。
			程序：
			#include<stdio.h>
			
			struct A
			{
				int a;
				char b;
			};
			
			void func(struct A a1)
			{
				printf("&a1 = %p.\n",&a1);
			}
					
			int main(void)
			{
				struct A a =
				{
					.a = 4,
					.b = 'A',
				};   			//gcc支持的一种赋值方式。
				func(a);			
				printf("&a = %p.\n",&a);
							
				return 0;
			}
		
			打印出的&a与&a1地址不相同，证明子函数接收的只是a的拷贝。
			
			2.当结构体变量很大传参是效率会很低，应该用指针来传参，通过指针访问实参提高效率。
			程序：
				#include<stdio.h>
			
				struct A
				{
					int a;
					char b;
				};
				
				void func(struct A *a1)
				{
					printf("a1 = %d.\n",a1->a);
					printf("&a1 = %p.\n",a1);
				}
						
				int main(void)
				{
					struct A a =
					{
						.a = 4,
						.b = 'A',
					};   //gcc支持的一种赋值方式。
					
					printf("a.a = %d.\n",a.a);
					printf("&a = %p.\n",&a);
					func(&a);
					
					return 0;
				}
				&a 与 &a1相同。
			
		(5)传值调用与传址调用
			
			例：
				#include<stdio.h>
				
				void swap1(a,b)
				{
					int tmp;
					tmp = a;
					a = b;
					b = tmp ;
					
					printf("a = %d,b = %d.\n",a,b);
				}
				
				void swap2(*a,*b)
				{
					int tmp;
					tmp = *a;
					*a = *b;
					*b = tmp ;
					
					printf("a = %d,b = %d.\n",*a,*b);
				}
			
			
				int main(void)
					{
						int x = 2,y = 3;
						swap1(x,y);		//只是交换了x，y的副本。
						swap2(&x,&y);	//x，y真的被改变了。 
						
						return 0;
					}
					
			总结：C语言本身函数调用一直是“传值”的，只不过所传的值可以是变量，也可以是变量的指针。当传的是变量的指针，可以通过指针解引用方式改变变量本身。
		
	10.输入型参数与输出型参数
		
		(1)形参与返回值
			
			1.函数名是一个符号，表示整个函数代码段的首地址，实质是一个指向这个函数的指针。
			
			2.形参是函数的输入部分，返回值是函数的输出部分。函数就相当于一个加工的机器。形参就相当于原材料，返回值就相当于加工后的成品。
			
			3.函数传参虽然没全局变量快捷，参数多的话开销也会很大，但是可以让程序更加容易掌握。可以用把参数打包成结构体的再传参的方法来解决。
			
		(2)const指针
			
			保护数据不被修改。
			
		(3)函数需要外部返回多个值时怎么办。
			 
			编程中函数的输入和输出都是靠函数参数的，返回值只是用来表示函数执行的结果是对(成功)还是错(失败)。 
			
		(4)总结
				
			如何判断参数在函数中做输入还是输出。
			函数传参如果是普通变量，那肯定是输入型参数。
			函数传参如果是指针变量，那就是两种情况：
				1.作输入函数，就在指针面前用const修饰。
				2.作输出函数，就不用用const修饰。
			
			
			
			
			
			
			
			
			
			
			
			
			
		
		
		
		
		