4.5
	1.程序中内存从哪里来
		
		(1)程序执行需要内存支持
			
			1.内存是程序的立足之地(程序是放在内存中运行的)。程序运行时需要内存存储一些临时变量。
			
		(2)内存管理最终是由操作系统完成的
			
			1.内存在物理上是一个硬件器件，由硬件系统提供。
			2.内存是由操作系统统一管理，为了方便与合理，操作系统提供了多种机制来让程序员应用程序使用内存。程序根据自己的实际情况来选择某种方式来选择内存、使用内存、释放内存。
				
		(3)获取内存的三种方式：栈(stack)、堆(heap)、数据区(.data)		
				
	2.栈的详解
		
		(1)运行时自动分配&自动回收
			
			定义局部变量时，编译器自动在栈中分配内存空间。程序员不用手动干预。
		
		(2)反复使用
			
			程序会反复使用栈内存的那块空间。操作系统会给每个程序分配栈空间(4k~10k)。管理方式为 先进后出。
			
		(3)脏内存
			
			栈内存反复使用，每次使用后程序不会去清零里面的值。所以定义局部变量时要同时初始化。
			
		(4)临时性	
			
			栈空间内存的值不是一直存在的(反复使用)，是临时的。
			
			一个函数不能返回栈变量(局部变量)的指针：
				因为当函数执行完毕后，内存已经释放了，其他地方定义局部变量时可能会把那内存挤掉，导致内存对应的值变了。
				
				程序:
					int func(void)
					{
						int a = 4;
						return = &a;
					}
				编译器会提示警告。
		
		(5)栈会溢出(stack overflow)
			
			操作系统事先给定了栈的大小，如果函数中无穷尽地分配栈内存总会溢出，导致程序错误。
			
			void stack_overflow(void)
			{
				int a = 4;
				stack_overflow();	//递归
			}
		
	3.堆的详解	
		
		(1)操作系统堆管理器管理：
			
			1.堆管理器是操作系统的一个模块。
			堆管理内存方式相对栈比较灵活，按需分配。操作系统先把小部分内存分配给每个进程(程序)作为栈，其他大块内存作为堆。各进程可以按需向堆申请内存，使用完释放(程序员手动申请&释放)。				
		
			2.脏内存
			
			堆内存也是反复使用的，用完后不会清零。
			
			3.临时性
			
			堆内存之间malloc和free之间属于我这个进程，可以访问。其他情况不可以访问，否则会出错。
		
			4.堆内存使用范例(申请&释放程序：申请malloc 释放free.)
				
				
				(1)malloc返回值的是void *类型的指针。实质上是堆管理器分配给程序员本次申请那段内存的首地址。
				因为堆不知道程序员要向内存存入什么类型的数据，所以返回void类型指针。void是万能类型，可以在需要时候再去指定它的真体类型(强制转换)。

				(2)对应头文件是：stdlib.h
				
					例:	int *p = (int *)malloc(1000*sizeof(int));	//申请内存
		
						if(NULL == p)
						{
							printf("malloc error.\n");				//检验是否申请成功
						}
						
						*(p+0) = 4;
						*(p+1) = 6;
						free(p);									//使用后释放。释放后p就不应该再使用了，因为堆可能会把内存分配给其他进程。
				
					注意：内存使用时候不能对p重新赋值，否则所申请的内存会丢失，直到当前程序结束时操作系统才会回收这段内存。
						
						p = NULL;
						p = &a;
		
				(3)	探讨malloc
					
					gcc中malooc默认是以16字节为分配单位。如果malloc申请小于16字节的大小时(即使是 malloc(0))，也会返回一个16字节的内存(按块分配)。 
					
					申请多少字节空间就使用多少空间，不要跨界访问，否则就有可能出现错误。
					
	4.代码段、数据段、bss段
		
		(1)编译器再编译程序时候将所有元素分成一些组成部分，各部分构成一个段，所以说段是可执行程序的组成部分。
				
		(2)	代码段：程序中的可执行部分，代码段就是函数堆叠而成的。
			
			数据段(也被称为数据区、静态数据区、静态区)：数据段就是程序中的数据，就是C语言程序中的全局变量(非0)。(注：全局变量算是程序的数据，局部变量算作函数的数据。)
				
			bss段(也被称为ZI(zeri initial)段)：bss段的特点别就是被初始化为0(未定义的全局变量默认为0)，本质上也属于数据段。可以理解为被初始化为0的数据段。 	
								
		(5)有些特殊数据会放在代码段
							
			1.C语言中使用 char *p = "linux"；定义字符串时"linux"实际被分配在代码段。这段其实是一个常量字符串而不是变量字符串，不能通过p修改。
					
			相当于const char *p = "linux"；
				
			2.const型常量实现的方法	：
				
				(1)编译器将const修饰的变量放在代码段，以实现不能修改。这种无法绕过编译器修改，运行也会报错。
				
				(2)由编译器检查以确保const型常量不会被修改，这时const常量还是跟普通变量一样放在数据段(gcc中就是这样实现)。这种可以绕过编译器修改。
				
		(6)显示初始化为非零的全局变量和静态局部变量放在数据段	
			
			放在数据段(.data)的变量有2种：
				
				第一种：显示初始化为非零的全局变量。
				第二种：静态局部变量，也就是static修饰的局部变量。(普通变量分配在栈上)。
				
		(7)并未初始化显示初始化为零的全局变量放在bss段
			
			与.data并没有本质区别。不用明确区分。
			
		(8)总结：C语言中所有变量和常量所使用的内存无非以上三种情况(数据段(全局变量)、栈(局部变量)、堆(malloc申请内存))。	
				
			相同点：三种方法都可以给程序提供可用内存。	
				
			不同点：
				栈内存：对应C中的普通局部变量(别的变量用不了)。
				
				堆内存：完全独立于程序存在与管理，程序员手工申请malloc，使用后释放free。
				
				数据段：对应C程序中的全局变量和静态局部变量，它的维护与管理也是自动的。
				
			使用例子：
				
				char str[] = "linux";				//全局变量
			
				int main(void)
				{
					char a[] = "linux";				//局部变量
					char *p = (char *)malloc(5);	//malloc申请内存空间
					
					if(NULL == p)
					{
						printf("malloc error.\n");
					}
							
					memset(p, 0, 10);				//清零功能，string.h
					strcpy(p,"linux");				//
				}
				
			不同存储方式有不同特点：
				
				1.函数内部临时使用，就定义局部变量。
				2.堆和数据段几乎拥有完全相同属性，大部分时候可以相互替换。但是生命周期不一样，堆内存生命周期从malloc开始到free结束，而全局变量是从整个程序执行时开始，直到程序结束才结束。所以，当变量只在程序的一个阶段有用，就适合堆内存；如果变量本身和程序一生相伴，就适合用全局变量，一般情况下使用堆类存比较普遍。(类似于租房和买房)
				
	
				
				