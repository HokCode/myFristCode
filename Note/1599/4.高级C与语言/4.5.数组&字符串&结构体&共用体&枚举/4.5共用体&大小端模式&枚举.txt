	12.共用体union
		
		(1)共用体union和结构体struct在类型定义、变量定义、使用方法上很相似。
				
			定义一个共用体：
				
				union myunion
				{
					int a;
					char b;
				};
				
		(2)共同体和结构体的不同：
		
			1.因为共用体内的元素是使用同一个内存单元的。可以理解为同一个内存空间，有多种解析方式。				
			例子：
				a 和 b是相关的。当给a赋值int a = 20;打印b是也是b = 	21。a和b其实是指向同一块内存空间，只是对这块空间有个字不同的解析方式。(访问a时是用int的解析方式,b同理)。
				
			2.共用体的大小：取最大元素的大小作为共用体的大小。union中的元素不存在内存对齐问题，因为它实际只有1个内存空间，都是同一个地址开始的。
			
		(3)	主要用途
			
			1.适用在需要对同一个内存单元进行多种不同规则解析的情况。
				
			2.可以用指针和强制类型转化替代共用体，但是共用体使用起来更便捷，更容易理解。	
				
	13.14.大小端模式
	
		(1)什么是大小端
			
			1.大端模式(big endian)和小端模式(little endian)。
			2.过去在串口等串行通信中，一次只能发1个字节。如果要发送一个int类型的数，是按照byte0 byte1 byte2 byte3的顺序发送，还是反过来呢？规则就是发送方和接收方必须按照同样的字节顺序通信。这就过去通信系统中的大小端模式。
				
			3.现在的大小端更多是指计算机存储系统的大小端(计算机内存/硬盘)。一个32位的二进制在内存中存储时有2中分布方式:
			
				大端：高位(高字节)->低地址(内存地址)。
				小端：高位->高地址。
				
				图例：	3  	2  	1  	0	(小端模式)		3  	2  	1  	0	(大端模式)
						12	34	56	78					78	56	34	12
				
				两者相比本身没有优劣之分，理论上都可以。但是存储和读取时要按照同样的模式来进行，否则会出错。	
				
			4.现实情况：有些CPU公司用大端(C51单片机)；有些CPU用小端(ARM)。现在公司大多数用小端模式。所以，当不知道当前环境用大端模式还是小段模式，就要用代码来检测。
				
		(2)用union来测试机器的大小端模式
			
			union myunion
			{
				int a;
				char b;
			}			
			
			int endian(void)
			{
				union myunion u1;
				u1.a = 1;			//地址0的那个字节内是1(小端)，是(0)大端。
				return u1.b;		//返回是1，是小端模式。返回是0，是大端模式。
			}
				
			分析：union中元素时共用同一内存的。int是4个字节，char是1个字节，如果小端模式两者都能读到1。如果是大端模式，char就会读成0；	
				
		(3)用指针方式测试机器的大小端
			
			int endian(void)
			{
				int a = 1;
				char b = *((char *)(&a));
				return b;
			}
				
			原理与union测试相似。	
				
		(4)一些无法测试大小端的方式
			
			1.位与运算方式：无法测试机器的大小端模式(表现为大小端机器&运算后的值相同)。
				
				分析：因为编译器运算作&运算时高字节对高字节，低字节对低字节的，与二进制存储无关。
				
			2.移位方式：	
				
				分析：原因和&运算符不能测试一样。右移运算永远是将低字节移除，而和二进制存储时这个低字节在高位还是低位无关。
				
			3.强制类型转换(转成char类型)
				
				分析：与2、3点同理。
				
		(5)通讯系统中的大小端(数组大小端)		
				
			在通信协议中，大小端是很重要的。因为串口每次发送只能发送一个字节，所以通信双方需要有一个协议(定义大小端,先发低字节还是先发高字节)。

			
	15.枚举型(enumeration)	
			
		(1)枚举在C语言中其实是一些符号常量集：枚举定义了一些符号，这些符号，每个符号和一个int型常量绑定。这些符号表示自定义常量的识别码，让编译器识别。
		
		(2)枚举定义方法
			
			enum return_value
			{
				ERROR,		//枚举内的元素是常量，枚举常量是全局的。可以通过"ERROR = 20"给其赋值，对应的RIGHT会等于25.默认时候是0
				RIGHT,		//enum return_value类型元素的赋值范围。
			};
			
			int main(void)
			{
				enum return_value r1;	
			}

			枚举符号常量和其对应的常量数字相对来说，数字不重要，符号才重要。所以一般情况下不明确指定符号所对应的数，让编译器自动分配(编译器会从0开始分配)。注意：枚举内的的常量后面加的是','。
		
		(3)枚举的作用
			
			1.枚举其实是对1、0这些数字进行符号化编码，符号的意义是显然的，很容易看出，让代码更清晰。
			
			2.宏定义也是不用数字而用符号，所以宏定义和枚举有相似之处，经常用来解决类似问题。
		
		(4)宏定义与枚举的区别
			
			1.枚举将多个有关联的符号封装在一个枚举中，而宏定义是散的(一个一个的)。

			2.当要定义的常量是有限或有联系的集合时(一个星期7天)，适合用枚举。
	
			3.当要定义的常量之间无关联，或者无限的，适合用宏定义。


















		
				
				
				
				
				
				
				
				
				
				
				
				
				
				