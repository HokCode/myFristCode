5.C语言字符串类型
		
		(1)C语言中没有原生字符串类型
				
			1.C语言没有string类型，C语言中的字符串时通过字符指针来间接实现的。	
				
		(2)C语言使用指针来管理字符串
			
			1.C语言中定义字符串：char *p = "linux"；此时p叫做字符串，实质只是一个字符指针，p指向了一个字符串的起始地址。
				
		(3)C语言字符串本质
			1.字符串时一串字符，反映在现实中就是文字、符号、数字等人用来表达的字符，反映在编程中的字符就是字符类型的变量。C语言中使用ASCII码对字符进行编程。字符串就是多个字符打包一起共同组成的。
			
			2.字符串在内存中就是多个字节连续分布构成的。(类似于数组)
				
			3.字符串3个核心：
				
				(1)指针指向字符串头。
				(2)固定尾部(字符串总是以'\0'来结尾，但'\0'不属于字符串)。'\0'是一个ASCII字符，是编码为0的字符(与数组0不同)。所以C语言中不可能存在一个有'\0'字符的字符串。
				
				(3)组成字符串的字符彼此地址相连。
				
		(4).指向字符串的指针和字符串本身不是同一种东西
				
			1.char *p = "linux";这段代码中，p本质上是一个字符指针，占4个字节；"linux"分配在代码段，占6个字节(加上'\0')。p叫做字符串指针，本身不是字符串。
				
		(5)存储多个字符的2种方式：字符串和字符数组
			
			1.字符串	:	char *p = "linux";
			
			2.字符数组	:	char a[] = "linux";
				
	6.字符串和字符数组的差别
		
		(1)字符数组初始化与sizeof、strlen
				
			1.strlen是C语言的一个库函数，原型是：size_t strlen(const char *);返回这个字符串的长度(以字节为单位)。返回的长度不包含字符串结尾的'\0'。通常通过用strlen函数来计算得到字符串长度。
			
			2.字符数组初始化
				
				(1)	char a[5] = "linux";
				
				(2)sizeof(数组名)得到的永远是数组的元素个数(也就是数组大小)，和数组中有无初始化无关。
				
				(3)strlen是用来计算字符串长度的,只能传递合法的字符串进去。
				
				(4)定义数组时没有明确给出数组大小(char a[]),则必须同时给出初始化式，编译器会通过初始化式去自动计算数组的大小。
				
				
			3.字符串初始化
				
				(1)char *p = "linux" ;
				
				(2)只能用strlen来计算数组大小。用sizeof只能返回指针的大小，和字符串长度无关。
		
		(2)字符数组与字符串的本质差别(内存分配角度)
			
			1.定义一个字符数组a，char a[] = "linux";数组a占6个字节。右值编译器只存在于编译器中，变奇艺将用它来初始化字符数组a后丢弃掉(也就是说内存中是没有"linux"这个字符串的)。相当于 char a[] = {'l', 'i', 'n', 'u', 'x', '\0'};
				
			2.定义一个字符串p,char *p = "linux";字符指针p和字符串一共占10个字节，分配在栈上。同时还定义了一个字符串，分配在代码段。然后把代码段中的字符串的首地址('l'的地址)赋值给p。
				
			总结对比：
				字符数组本身是数组，数组自身带内存空间，可以用来存放东西。
				
				字符串本身是指针，本身占4个字节，不能用来存数据，只能用来存字符所在内存空间的首地址。所以只能把有效数据存在别的地方，然后把地址存在p中。虽然麻烦，但是相对比较灵活。
				
	7.结构体详解
		
			(1)结构体是一种自定义类型(UDT)
				
			(2)结构体使用时先定义结构体类型再类型定义变量
				
				1.先定义结构体类型，再用类型定义变量。
					譬如：
						//定义类型
						struct people
						{
							char name[20];
							int age;
						};
						int main(void)
						{
							struct people p1;	//使用结构体类型定义变量							
							return 0;
						}
					
				2.也可以同时定义结构体类型和结构体变量。
					
					譬如：
						struct people
						{
							char name[20];
							int age;
						}s1;					//定义类型同时，定义结构体变量s1。注意区分typedef。
					
			(3)从数组到结构体的进步之处
					
				1.结构体可以认为是从数组发展而来的，数组是最简单的数据结构，结构体比数组更复杂一些。
				
				2.数组有2个明显缺陷：定义是必须明确给出大小，这个大小在以后不能更改；数组要求所有的元素类型必须一致。
						
				3.结构体：可以把结构体理解成一个元素类型可以不同的数组。
				
			(4)结构体变量中的元素如何访问？
					
				1.用 . 或者 -> 的方式来访问。(C语言规定，用结构体变量访问元素时用. ,用结构体变量的指针来访问元素用 -> )。
				这些访问方式的本质也是指针访问。
						
					例子：
						struct mystruct
						{
							int a;
							double b;
							char c;
						}
						
						int main(void)
						{
							struct mystruct s1;
							s1.a = 12;			//相当于：int *p1; p1 = (int *)&s1; *p1 = 12;
							s1.b = 8.8;			//相当于：double *p2; p2 = (double *)((int)&s1 + 4); *p2 = 8.8;转成int类型+4。
							s1.c = 'b';			//相当于：char *p3; p3 = (char *)((int)&s1 + 12); *p3 = 'b';
						}
				
	8.9.10.结构体详解
		
		(1)举例：
			
			struct mystruct
			{
				char a;	//a实际占4个字节，而不是1个字节。
				int b;	//	
			}
			
			1.结构体中元素的访问本质上还是用指针方式，结合这个元素在整个结构体的偏移量和这个元素的类型来进行访问。
					
			2.但实际上结构体元素的偏移量非常复杂，因为结构体要考虑元素的对其访问，所以每个元素实际占得字节数和自己本身的类型所占的字节数不一定完全一样(见上面的例子)。
				
		(2)结构体为何要对齐访问
			
			1.为了配合硬件，硬件本身受物理限制，如果对齐排布和访问会提高效率。
				
			2.内存本身是一个物理器件(DDR内存芯片，SoC上的DDR控制器)。本身有一定的局限性：如果访问时按照4字节对齐访问，效率是最高的。
				
			3.Cache的一些缓冲特性，还有其他硬件(MMU、LCD显示器)的一些内存依赖性，也为导致我们需要对齐访问。
				
			4.对齐访问牺牲了内存空间，换取了速度性能。非对齐访问牺牲了速度性能，换取了内存空间的完全利用。	
				
		(3)编译器本身可以设置内存对齐的规则。		
				
			1.32位编译器，一般编译器默认对齐方式是4字节对齐(效率高)。	
				
			2.结构体整体本身必须安置在4字节对齐处，结构体对齐后的大小必须是4的倍数(编译器设置为4字节对齐时)。
				
			3.结构体中每个元素都必须对齐存放，每个元素本身都有自己的对齐规则。	
				
			4.编译器考虑结构体存放时，会以满足2、3点要求的最少内存需求的排布来算。
				
			存放细节说明：
				struct mystuct
				{
					int a;		//	4
					char b;		//	2(1+1)
					short c;	//	2
				}
			从第一个元素开始考虑，放下一个元素时，先考虑需不需要填充。如int类型放好后刚好对齐，放完char类型后，需要填充一个字节，再放下short类型(short类型只能放在0、2、4等地址处)。所以以上结构体总共8个字节。
			
			注意：结构体选择对齐参数时，会先从结构体元素中，选中一个所占字节最大的元素，再将其与编译器默认对齐参数比较，选择相对较小的，作为本结构体的实际对齐参数。
				
		(4)gcc支持但不推荐的对齐指令：	#pragma pack()		
				
			1.编译器(32位系统)的默认对齐方式是4。而如果需要更改编译器对齐方式，就需要指令#pragma pack.	
				
			2.常用的设置编译器对齐命令有2种：
				
				(1)第一种：#pragma pack()，这是设置编译器1字节对齐(也叫设置编译器不对齐、取消编译器对齐)。
				
				(2)第二种：#pragma pack(4)，这个括号中的数组就表示我们希望多少个字节对齐。
			
				(3)我们需要#pragma pack(n)开头，以#pragma pack()结尾来定义一个区间，这个区间的对齐参数就是n字节。
				
				(4)#pragma pack()在很多C环境下是支持的，但是gcc不建议使用。			
			
			3.gcc推荐的对齐指令  
				
				(1) __attribute__((packed))(取消设置对齐) attribute(属性)
				
					使用时直接放在要进行对齐的结构体类型定义的后面。无法对变量使用。
				
				例子：
				
				struct mystruct
				{
					int a;	// 4
					char b;	// 1
				}__attribute__((packed));	//取消自动对齐
				
				
				
				(2)__attribute__((aligned(n)))(设置几个字节对齐)	
					使用方法与第(1)点类似。作用是让整个结构体变量整体进行n字节对齐，而不是结构体内各元素也要n字节对齐。比如在以下例子中，结构体的大小为1024(与 #pragma pack的区别).
					
				例子：
				
				struct mystruct
				{
					int a;	// 4
					char b;	// 1
				}__attribute__((aligned(1024)));	
				