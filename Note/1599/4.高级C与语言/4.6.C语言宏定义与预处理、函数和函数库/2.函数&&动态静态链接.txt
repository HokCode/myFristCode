4.6
	5.函数的本质
		
		(1)C语言中为什么会有函数
			
			1.整个程序分成多个源文件，一个文件分成多个函数，一个函数分成多个语句。这样编写可以分化问题，便于分工。
				
			2.函数的出现是人得需要(分工)，不是机器(编译器、CPU)的需要。
			
			3.函数的目的就是实现模块化编程(可装卸、可自由组合)，提高程序的可移植性。
			
		(2)函数数学的一般原则
			
			1.遵循一定格式：函数的返回类型、函数名、参数列表等。
			
			2.一个函数只做一件事情：函数不能太长、也不宜太短((短就用inline)。
			
			3.传参不宜过多。
				(1)在ARM体系下，传参不宜超过4个(效率太低)。如果需要传的参数过多，考虑结构体。	
			
			4.尽量少碰全局变量
			
				(1)函数最好用传参返回值来和外部交换数据，不要用全局变量。碰了全局变量，别的程序引用都要重新编写(破坏了模块化)。
			
		(3)函数是动词、变量是名词
			
			1.函数被编译成可执行代码，变量(主要指全局变量)经过编译后变成数据或者在运行时变成数据。
			
			2.代码为了加工数据，数据必须借助代码来起作用。数据相当于原材料，代码相当于流水线。
			
		(4)函数的实质：数据处理器
			
			1.程序的主体是数据，程序运行的主要目标是生成目标数据。
			
			2.得到目标数据的2个必须因素：程序的输入数据(原材料)和程序(加工算法)。
			
			3.函数没有执行时，不占内存(cpu、内存)。函数运行完后释放占用的资源。
			
			4.整个程序运行其实就是很多个函数相继运行的连续过程。
			
	6.函数的基本使用
		
		(1)三要素：定义、声明、调用
			
		(2)函数原型和作用
			
			1.函数原型就是函数的声明：函数名、返回值类型、参数列表。
				
			2.主要作用是给编译器提供原型，让编译器再编译程序时帮我们进行静态类型检查。
			
			3.编译器编译文件时是按照文件中语句的先后顺序执行的。编译器从第一行开始编译，遇到函数声明就会将其收到编译器的函数声明表中，当遇到一个函数调用时，就会去那个表寻找(相对应的函数有且只能有一个)。
			
	7.递归函数
			
		(1)递归函数
				
			1.递归函数就是在函数中调用了自己的函数。
			2.递归不等于循环。
			3.递归函数解决的问题：阶乘、斐波那契数列。
				
				斐波那契数列：f(n) = f(n-1)+f(n-2);
			
		(2)函数的递归调用原理
				
			1.实际上递归函数实在栈内存上递归执行的，每次递归执行一次就需要耗费一些栈内存。
			
			2.栈内存大小是限制递归深度的重要因素。
			
		(3)递归函数的原则
				
			1.收敛性：递归函数必须有一条终止递归的条件。
			
			2.栈溢出：如果递归函数没有收敛性，就会导致栈溢出。
	
	8.函数库
		
		(1)什么是函数库
			
			1.函数库是一些事先写好的函数的集合。		
			2.函数是模块化的，因此可以被反复使用。
			
		(2)函数库的提供形式: 动态链接库与静态链接库
			
			1.早期的函数共享都是以源代码的形式进行的。但是这种方式导致了无法以商业化形式来发布函数库。所以就出现了以库(静态库和动态库)的形式来提供。
			
			2.静态链接库：
				
				商业公司将自己的函数库源代码经过只编译不链接形成 .o 文件，然后用ar工具将 .o 文件归档成 .a 的归档文件(也叫静态链接库文件)。公司通过发布.a库文件和.h头文件来提供静态库给客户使用。			
				通过.h文件可以得知库中库函数的原型，然后在自己.c文件中直接调用这些库函数。在链接时，链接器会去.a文件中拿出所对应的.o文件(二进制代码段)链接进去，形成最终的可执行程序。
			
			3.动态链接库(效率更高、省内存)
				
				(1)静态链接库缺陷：用户在链接自己的可执行程序时就把所调用的库中函数的代码段链接进可执行程序中了。这样会很占空间。当多个程序需要调用同一个库函数时，还会导致重复加载，浪费内存。
				
				(2)gcc中编译默认使用动态库，可通过 gcc XX.c -static 来强制静态链接库。
			
				(3)动态链接库：本身不将库函数的代码段链接入可执行程序，只是做了个所要调用函数的标记。当程序执行时，会去加载这个动态库到内存中。以后的程序需要调用此库函数，就会跳转到第一次加载库函数的地方去执行，不会重复加载。
			
		(4)库函数的使用
			
			1.包含相应头文件。
			
			2.调用库函数时，注意函数原型(函数名、几个参数、返回什么值)。
			
			3.有些库函数链接时，需要额外用-lxxx来指定链接(数学库函数)。
			
			4.如果是动态库，要注意 -l指定动态库地址。
			
	9.字符串函数
		
		(1)字符串处理函数
			
			1.字符串处理的需求导致了字符串处理函数的出现。
			
		(2)常用字符串处理函数
			
			1.C库中字符串处理的函数都包含在 string.h 中。
			
				memcpy(void *dest, const void *src, size_t n);
					
					把src中的n个字符赋值到dest中。两个字符串区间不能重合。
			
				memmove(void *dest, const void *src, size_t n);
					
					与memcpy类似，但两个字符串区间可以重合。
			
				memset
				
				memcmp
				
				memchr
				
				strcpy
				
				strncpy
				
				strcat
				
				strncat
				
				strcmp
				
				strncmp
				
				strdup
				
				strndup
				
				strchr
				
				strstr
				
				strtok
				
	10.	数学库函数	
		
		(1)math.h
			
			1.真正的数学运算的函数定义在：mathcalls.h
			2.使用数学库函数的时候，只需包含math.h即可。
				
		(2)	计算开平方
			
			1.double sqrt(double x);
			
			
		(3)链接错误(sqrt例子)
			
			函数有声明(在头文件math.h中)有引用(在math.c)，但是没有定义，链接器找不到函数体。sqrt本来是库函数，在编译器库中有.a(静态)和.so(动态)链接库。
			
			C链接器的工作特点：因为库函数有很多，链接器去库函数目录搜索的时间比较长，所以链接器默认只寻找几个常用的库。
			
			所以当调用一些不常用的库的函数，需要程序员链接时给出要查找的库的名字。在链接时，用"-lXXX"只是链接器去libXXX.so去查找。
			
			报错例子：	w.c:(.text+0x35): undefined reference to `sqrt' 
						collect2: ld returned 1 exit status
			
		(4)编译链接时加 -lm
			
			gcc XXX.c -lm
			
			1.告诉链接器到libm中去查找我们需要调用的函数。
			
			2.在高版本的gcc中，有时可以不加 -lm 也可以编译链接。
			
		注意：可以通过 ldd+可执行文件 查过程序所用到的库。(如：ldd a.out)
			
	11.	自己制作静态链接库
		
		(1)自己写源代码并做成静态链接库。
				
			1.新建hgj.c(.c文件)编写源代码。(没有主函数)
			
			2.新建hgj.h(头文件)声明.c文件中的函数。
			
			3.只编译，不链接
				
				代码：gcc hgj.c -o hgj.o -c
				
			4.归档得到.a的归档文件
			
				代码：ar -rc libhgj.a hgj.o		
				
					ar:一个命令。归档器，创造归档文件(静态链接库)。
				
					-rc：创造。
				
					libhgj：lib+库名称。库名称不能随便起。后缀名是.a
				
					hgj.o:原材料。
			
		(2)使用静态链接库。	
			
			发布库时，发布 libxxx.a 和 lib.h 即可。
			
			gcc XXX.c -o XXX -lhgj -L.
			
			-L. :告诉链接器去当前目录寻找库函数(libGJones.a)。否则链接器只会去默认目录寻找。
			
		(3)除了 ar 命令外，还有一个nm命令
			
			nm命令：可以用来查看一个.a文件中都有哪些符号。
			
	12.动态链接库
		
		(1)动态链接库的后缀名是.so(对应windows系统中的dll)。
			
		(2)创建动态链接库
							
			1.新建hgj.c(.c文件)编写源代码。(没有主函数)
			
			2.新建hgj.h(头文件)声明.c文件中的函数。
			
			
			3.只编译，不链接
				
				代码：gcc hgj.c -o hgj.o -c -fPIC
					
					PIC:位置无关码。
			
			4.生成.so文件
				
				代码：gcc -o libhgj.so hgj.o -shared
					
					shared：按照共享库链接方式链接。
			
		(3)使用自己创建的共享库
			
			1.发布库时，发布 libxxx.so 和 xxx.h 即可。
			
			2.编译代码
				
				gcc XXX.c -o XXX -lhgj -L.	

				编译通过，但运行出错。(注意：如果静态链接库(.a)和动态链接库(.so)同时出现，链接器会优先选择动态链接库。)
				
							
				
				出错原因：在运行 XXX 程序的时需要加载动态链接库，于是会去固定目录尝试加载.so文件，如果加载失败，就会运行错误。
				
				解决方法一：把.so文件放入固定目录下(/usr/lib)。(缺陷：导致目录文件太多)
					
					代码：cp XXX.so /usr/lib
					
				解决方法二：使用环境变量LD_LIBRARAY_PATH。操作系统在加载固定目录/usr/lib前，会先去LD_LIBRARAY_PATH环境变量所指定的目录寻找，再去/usr/lib找。
					
					代码：	export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:当前目录路径。
							echo $LD_LIBRARY_PATH	//当前环境变量目录。	
				
				解决方法三：(只限于ubunto)用ldconfig。给系统指定(默认)目录，再加一个目录。(缺陷：与方法一类似)
				
			3.ldd命令
			
				作用：可以在一个使用了共享库的程序执行之前解析出这个程序使用了哪些共享库，并查看哪些共享库是否能被找到和解析(程序是否能正确执行)。
				
				无法找到或无法解析时，.so文件后会有 not found。
			