4.6
	1.2.3.4.C语言预处理
		
		(1)源代码到可执行程序的过程
			
			1.源代码.c -> (预处理) -> 预处理过的.c源文件 -> (编译) -> 汇编文件.s -> (汇编) -> 目标文件.o -> (链接) -> elf可执行程序
			
			预处理用预处理器，编译用编译器，汇编用汇编器、链接用链接器，这几个工具再加上其他工具，合起来叫编译工具链。gcc就是一个编译工具链。
			
		(2)预处理的意义
			
			分担编译器的工作，完成一些编译器的非核心功能(杂事)，让编译器更在聚焦核心功能。
			
		(3)编程中常见的预处理(部分重要的)
			
			1.头文件 #include
			2.注释
			3.条件编译 #if #eif #endif #ifdef #undef
			4.宏定义 #define
			
		(4)gcc	
			
			1.gcc编译时可以给一些参数来做些设置。
			譬如：
				gcc x.c -o xx 			可以指定可执行程序的名称(xx)。
				
				gcc xx.c -c -o xx.o		可以指定先编译不链接，也可以生成.o的目标文件。
				
				gcc -E xx.c -o xx.i		可以指定只预处理。通常用这种方法来研究预处理过程。帮助debug程序。
			
			总结：实验发现预处理后，宏定义(#define)本身不见了，但是typedef还是在。说明它们宏定义是预处理处理的，typedef是由编译器处理的。
				
		(5)C语言预处理实战
			
			1.头文件包含
				
				(1)#include <> 和 #include""的区别：
					
				
					#include<>	：告诉编译器这个头文件是系统提供的(就是系统自带的，不是程序员自己写的)，让其在系统指定目录找。
					
					#include""	：告诉编译器在当前目录寻找头文件，如果没找到，再去系统指定目录寻找。
			
					编译器允许用 -I 来附加指定其他的包含路径。这种时候也用<>。
			
				(2)头文件包含的实质：在预处理时把文件内容替换#include<xx.h>语句。
			
			2.注释
				
				(1)注释是给人看的，不是给编译器看的。所以在预处理阶段会擦掉程序中所有的注释语句，到了编译器编译阶段程序已经没有注释了。
			
			3.条件编译
				
				(1)
					#define NUM
					
					int main(void)
					{
						#ifdef NUM	//如果前面有定义NUM符号，执行以下内容。
						
						#else		//如果前面没有定义NUM符号，执行以下内容。
											
						#endif
						
						return 0;
					}
					
					可以用 #elif 多重判断。#undef 如果前面有定义一个宏，就注销这个宏。如果没有也不会报错。
					
				(2)#ifdef 和 #if 区别：
					
					#define XX (YY)
					
					#ifdef XX :主要判定XX这个符号在本语句之前是否被定义，只要定义了，语句就成立。
				
					#if (条件表达式) :只要判断()中的表达式是true还是false。如果用#if，就要写YY(让它可以判断)。
						例子：
							#define NUM 0
							
							int main (void)
							{
								#if(NUM == 0)	//条件成立，执行。
							
								return 0;
							}
			
			5.6.宏定义
				
				(1)宏的解析和使用
					
					1.解析规则：在预处理阶段，由预处理器进行原封不动的替换。
					
					2.宏定义替换，会递归进行，直到替换出来的值本身不再是一个宏为止。
			
					3.宏定义分为三部分："#define "，宏名，剩下的所有都是要代替的部分。
			
					4.带参数的宏(带参宏)
					
						例：#define X(a,b) (a+b)	//第三部分的括号最好加。
			
						宏的使用和带参函数非常相似。但是在定义带参宏时，每一个参数在宏体中引用时必须加括号，最后整体再加括号。
					
				(2)宏示例
					
					1.MAX宏(返回最大值)
				
						#defind MAX(a, b) ( ( (a)>(b) ) ? (a):(b) )
						
						(1)要使用三目运算符完成。
						(2)括号要补齐。
				
					2.SER_PER_YEAH, 用宏定义表示一年中有多少秒。
						
						#define SER_PER_YEAH (365*24*60*60)		//错误，超出范围。
						#define SER_PER_YEAH (365*24*60*60UL)	//正确写法。
						
						解析：当一个数直接出现在程序中，会被默认为int类型，一年的秒数刚好超过了它的表示范围。
						
				(3)带参宏和带参函数的区别		
					
					1.宏定义是在预处理期间处理的，而函数是在编译期间处理的。						      		
						宏定义是在调用宏体的地方原地展开宏体。函数调用是在调用函数处跳转到函数中去执行，执行完后再跳转回来。所以宏没有调用开销(时间)，函数有比较大的函数开销。
					
						解析：函数体很短时(开销时间占得比例大)，适合用宏定义。
				
					2.宏定义传参时不会检查参数的类型，返回值也不会附带类型。调用函数时编译器会做参数的静态检查，发现类型不匹配时会报错。
						
						譬如:	#defind MAX(a, b) ( ( (a)>(b) ) ? (a):(b) )
						
								可以传int类型的参数、float类型的参数或其他类型的参数。
			
						解析：如果代码很长，适合用函数。如果代码短的话，适合用宏。
					
				(4)内联函数和inline关键字
					
					(1)内联函数通过在函数定义前加inline关键字实现。
					
					(2)内联函数本质上是函数，有函数的有点(编译器会帮忙做静态类型检查)。同时也有带参宏的优点(不用调用开销，而是原地展开)。可以理解为带了参数静态类型检查的宏。
					
					(3)当函数体很短时用inline，既可以省去调用开销，也可以有编译器参数静态类型检查功能。(太长的函数一般不用inline)。
			
				(5)DEBUG调试(#ifdef, #elif, #else #undef, #endif)
			
	