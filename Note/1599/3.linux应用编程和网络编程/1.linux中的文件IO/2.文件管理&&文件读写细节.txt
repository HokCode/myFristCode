6.文件读写的一些细节
	
	(1)errno(error number)和perror(print error)
		
		1.错误号码。linux系统对各种常见错误做了一个小编号。
		
		2.errno是由OS来维护int类型的一个全局变量，OS内部函数都可通过设置errno来告知上层发生了什么错误。
		
		3.linux系统提供函数perror，perror会自动拦截数字errno并转成对应的错误信息并打印。如：
			
			perror("open")。发生错误时，系统会打印open: File exists
 
	(2)read和write的参数count	
		
		1.count表示希望写或读的字节数，返回值表示实际完成写或读的字节数。

		2.读取或写入一些设备文件时，有可能会被堵塞住。如：需要读取30字节，在读到20个时被堵塞。
		
		3.读取或写入一些庞大文件时(2MB)，不能一次性读完。应先把count设置成合适的数字(如2048)，通过循环多次读取或写入。
		
	(3)文件IO效率和标准IO
		
		1.文件IO：open、close、write、read等API函数构成的一套读写文件体系，这套体系好用但是效率不高。

		2.标准IO：应用层C语言库函数提供了一些用于文件读写的函数列表，如：fopen、fclose、fwrite、fread。这些标准IO都是由文件IO封装而来的。

		3.标准IO封装时为了在应用层添加一个缓冲机制，当使用fwrite写入内容时，会先进入应用层标准IO库自己维护的buf中。最后根据系统单次write的最佳count来写入内核中的buf。

7.linux系统如何管理文件
	
	(1)硬盘中的静态文件和inode(i节点)

		1.文件平时存放在硬盘，硬盘中以一种固定形式存储文件。

		2.一个硬盘可分为两大区域：一个是硬盘内容管理表；另一个是真正存储内容的区域。访问硬盘前要先查表，找到要访问文件对应的扇区。

	(2)操作系统从拿到文件名信息，到最终得到文件内容过程：

		1.查询文件管理表。管理表中以文件为单位记录了各个文件的信息，每个文件有一个信息列表(inode,i节点)，本质是一个结构体。信息包括：文件名、文件对应的扇区号和块号。
		
		2.inode是硬盘记录文件信息的数据结构。
			
		3.格式化硬盘(u盘)时，有快速格式化与底层(普通)格式化。
			
			快速格式化：只删除了u盘中的硬盘管理表(i节点)。
			
			底层格式化：把真正存储的内容都删除了。

	(3)内存中被打开的文件和vnode(v节点)
		
		1.一个程序运行就是一个进程，每个进程都有一个数据结构来记录进程的所有信息(进程信息表)。表中有一个指针会指向文件管理表。
		2.管理表记录了当前进程打开的所有文件及其相关信息。表中用来索引每个打开文件的index就是文件描述符fd。

		3.通过fd最终找到被打开文件的管理结构体vnode。一个vnode记录一个被打开的文件各种信息。

	(4)文件与流的概念
		
		1.流(stream)。文件以字符为单位被多次读取/写入，形成一个字符流。流是动态的。
		
		2.编程中的流是与IO相关的，即IO流。

8.lseek详解
	
	(1)lseek函数
		
		1.对文件读写前要先打开文件。用户读写的所有文件都是动态文件。文件在内存中的形态是文件流的形式。

		2.文件流表现在内存中若干连续的字节。在操作动态文件时，其实是通过文件指针来操作当前希望操作的位置的。

		3.open打开一个空文件时，文件指针默认指向文件流的开始。write和read函数自带移动文件指针功能，读/写了n个字节后，文件指针也会向后移动n个字节。
		
		4.在linux系统中也可用lseek来访问对应的文件指针。

			off_t lseek(int fd, off_t offset, int whence);

			whence：文件指针开始的地方，如：
			SEEK_SET：指向文件开头位置
			SEEK_CUR：指向文件当前位置
			SEEK_END：指向文件末尾位置

			返回值表示指针相对于文件开头移动的字节数。
			
	(2)用lseek计算文件长度
		
		思路：
		1.open打开文件，此时文件指针默认指向文件流的开头。

		2.利用lseek函数指向文件流末尾，返回指针移动的字节数，得到文件长度。

	(3)用lseek构建空洞文件
		
		1.空洞文件时文件中有一段是空的。
		
		2.打开一个文件后，用lseek函数往后跳过一段字节。再用write函数写入。

		3.空洞文件作用：可用于多线程共同操作文件，大大提高构建大文件的效率。多个构建文件线程共同合作构建文件。
		
9.多次打开同一文件与O_APPEND

	(1)重复打开同一个文件读取
		
		1.一个进程中两次打开同一个文件并分别读取时，两个文件对应2个不同的独立指针。

		2.linux系统的进程中不同fd对应不同的独立的文件管理表。

	(2)重复打开同一个文件写入
		
		1.一个进程两次打开同一个文件分别写入时，两个文件也对应2个不同的独立指针。后面写入会覆盖前面写入的内容。
		
	(3)加O_APPEND解决覆盖问题
		
		1.加入O_APPEND标志会使两个文件指针关联起来，一个指针移动另一个会一起移动。

		2.原子操作：整个操作一旦开始就不会被打断，直到操作结束其他代码才能得以调度运行。O_APPEND对文件的读写是原子操作。

