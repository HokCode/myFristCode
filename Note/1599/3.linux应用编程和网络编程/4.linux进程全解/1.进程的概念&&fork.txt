1.程序的开始和结束
	
	(1)main函数的调用
		1.编译链接时的引导代码。操作系统的应用程序在main执行前需要先执行一段引导代码。链接时由链接器将编译器中的引导代码和应用程序链接起来构成可执行程序。

		2.运行时的加载器。执行程序时(./a.out或代码中用exec族函数运行)，加载器负责将程序加载到内存中并执行。

		3.程序在编译链接时用链接器，运行时用加载器。
		
		4.argc和argv传参。在shell环境中，shell进程会把参数传给加载器；加载器在加载运行时，会把参数传给引导代码；引导代码在执行main函数时，会把参数传给main函数。

	(2)程序如何结束
		
		1.正常终止：return、exit、_exit

		2.非正常终止：自己或他人发信号终止
		
	(3)atexit注册进程终止处理函数
		
		1.通过atexit注册的终止处理函数，会在进程被终止前被执行。	
			
		2.先注册的后执行，后注册的先执行。	

	(4)return、exit和_exit的区别
		
		1.用_exit终止进程时，不执行atexit注册的进程终止处理函数直接终止。

2.进程环境
	
	(1)进程环境表介绍

		1.每个进程都有一份所有环境变量构成的一个表格，即当前进程可使用的环境变量。

		2.通过environ全局变量使用环境变量，声明后即可使用。因为进程环境表本质是一个字符串数组，所以这样声明:
			
			extern char **environ;

		3.可使用getenv函数得到某个环境变量的值。	
			
		4.一旦程序用到了环境变量，那么程序和操作系统就有关了。所以可能会出现同一程序在不同操作系统执行得到不同结果。

	(2)进程运行的虚拟地址空间
		
		1.操作系统中的每个进程都在独立地址空间中运行。每个进程的逻辑地址均为4GB(32位系统)，其中0~1G为OS，1~4G为应用程序。但实际没有那么多。
		
	(3)虚拟地址与物理地址空间映射的意义：
		
		1.进程隔离，提高进程安全性。
		2.多进程运行，所有进程运行地址都是在各自逻辑地址中的0地址开始，是个虚拟地址。系统会自动将其转换为物理地址，所以应用程序链接不需提供链接脚本。
			
		3.能提供虚拟地址到物理地址映射的系统，称为高级操作系统。	 

3.进程的引入	

	(1)进程的定义
		
		1.进程是动态过程，可理解为是程序的一次运行过程。

		2.进程控制块PCB(process_control_block)，内核中专门用来管理一个进程的数据结构。

		3.可通过ps命令查看进程信息:ps -aux或ps

	(2)进程ID
		
		1.命令获得进程ID：
		
			getpid：	获取当前进程的id。
			getppid：	获取父进程的id。
			getuid：	获取当前进程的实际用户id。
			geteyud：	获取当前进程的有效用户id。
			getgid：	获取当前进程的实际组id。
			getegid：	获取当前进程的有效组id。

		2.进程结束后，id不会被回收。重新运行也会重新分配pid。
			
	(3)多进程调度的原理
		
		1.操作系统同时运行多个进程。调度就是决定各进程运行的顺序和时长。

		2.实际上现代操作系统最小的调度单元是线程。

4.fork创建子进程
	
	(1)fork内部原理
	
		1.进程的分裂生长模式。当操作系统需要一个新进程来运行程序，会复制一个原有进程(PCB)得到一个新进程。
		
		2.原先的进程称为父进程，新进程称为子进程。

	(2)fork函数
		
		1.fork调用一次会返回两次。返回值等于0的是子进程；返回值大于1的是父进程。典型用法：
			
			pid_t p1 = -1;
			p1 = fork();
			
			if(p1 == 0)
			{
				//这里是子进程代码
			}

			if(p1 > 0)
			{
				//这里是父进程代码
			}

		2.调用fork后，父进程的返回值其实就是本次创建的子进程的PID。
		
		3.如果父进程比子进程先结束，父进程在结束后会把自己权限交给init进程，子进程的父进程就变成了init进程。

	(3)子进程要点
		
		1.子进程在建立后，其运行不依赖与父进程。

		2.子进程有自己独立的PCB。
		
		3.子进程被内核同等调度。
