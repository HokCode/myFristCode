5.父子进程对文件的操作
	
	(1)子进程继承父进程中打开的文件
		
		1.子进程与父进程同时写文件时，是接续写。

	(2)父子进程各自独立打开同一文件实现共享
		
		1.父子进程各自独立打开同一文件时，是独立写。
		
		2.open打开时加O_APPEND标志可以把父子进程的fd关联起来。

	(3)总结
		
		1.父进程在调用fork之前的工作对子进程有很大影响。调用fock之后在自己if里做的工作对子进程无影响。

		2.创建子进程最终目的是让他独立去运行另外的程序。

6.进程的诞生和消亡
	
	(1)进程0和进程1
		
		1.进程0中PCB的元素是内核搭建起来的。进程1是在内核态下通过进程0用fork生成的。
		
		2.vfork和fork相同，也是诞生新进程。

	(2)进程的消亡
		
		1.正常终止和异常终止。
		
		2.进程消亡时要释放它运行时消耗的系统资源(IO、内存)，linux操作系统会自动回收。但是没有回收进程本身占用的内存(task_struct和栈内存，8KB)
		
		3.父进程负责回收其子进程消亡后的子进程本身task_struct部分。

	(3)僵尸进程
		
		1.指子进程比父进程先结束，但父进程还没回收子进程本身8KB部分。这时的子进程称为僵尸进程。

		2.僵尸进程除了task_struct和栈外其余内存空间皆已清理。
		
		3.父进程通过使用wait或waitpid来回收子进程本身8KB部分；
		
		4.为了防止内存泄漏，父进程在自身结束时，也会回收僵尸进程剩余的8KB部分。

	(4)孤儿进程
		
		1.指父进程比子进程先结束，此时子进程称为孤儿进程。
		
		2.linux系统中规定：所有的孤儿进程会自动成为init进程的子进程。

7.父进程wait回收子进程
	
	(1)wait的工作原理
	
		1.子进程结束时，系统会向其父进程发送SIGCHILD信号。父进程收到信号后，调用wait函数(阻塞式函数)回收子进程。
		2.父子进程之间是异步的，在不同时钟下工作。SIGCHILD信号机制就是为了让父进程及时去回收僵尸子进程。

		3.如果父进程在没有子进程时调用wait函数，wait函数会返回错误。

	(2)wait函数
		
		pid_t wait(int *status);

		1.status是用来接收子进程结束时的状态参数。

		2.wait函数的返回值是本次wait回收的子进程的PID。如果当前父进程有多个子进程，wait函数会阻塞直到一个子进程结束wait才会返回。

		总结：
		wait主要用来回收子进程资源，回收同时还可知道被回收子进程的PID和退出状态status。

	(3)WIFEXITED、WIFSIGNALED、WEXITSTATUS宏
		
		1.与status结合使用用于获取子进程的退出状态。

		WIFEXITED(status)	正常终止(return、exit、__exit)
		
		WIFSIGNALED(status)	非正常终止(非正常终止)

		WEXITSTATUS(status)	得到正常终止子进程的返回值。

8.waitpid介绍
	
	(1)waitpid和wait的差别
		
		1.基本功能相同，都是回收子进程。返回值也是所回收子进程的pid。
		
		2.waitpid可以回收指定PID的子进程。
		
		3.waitpid可以阻塞式或非阻塞式两种工作模式。

	(2)waitpid原型
		
		pid_t waitpid(pid_t pid, int *status, int options);

		1.options是传给函数的参数，让函数实现某些特定功能：
		
			0		阻塞式(默认方式)
			WNOHANG	非阻塞式
			
		2.当pid参数为-1时，代表waitpid这时与wait一样不针对某个子进程。即以下写法时waitpid与wait相同：
			
			waitpid(-1, &status, 0);

		3.调用waitpid函数回收子进程时，如果提供的pid不存在，函数会返回-1；如果提供的pid存在，但没有回收成功，函数返回0.

	(3)竞态引入
		
		1.竞争状态：指在多进程环境下，多个进程同时抢占系统资源(内存、CPU、文件IO)。操作系统没处理好竞态会造成结果不确定。

