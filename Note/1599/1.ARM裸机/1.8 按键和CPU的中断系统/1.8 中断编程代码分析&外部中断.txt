1.8	
	8,9：中断处理编程
		
		(1)中断控制器初始化
		
			1.system_init_exception()，绑定异常向量表。
			
			2.VICnINTENCLEAR = 0xffffffff，n=0~3
				
				中断初始化之初要禁止所有中断。因为一开始中断打开时，外部或者硬件自己产生中断一定会寻找isr，如果我们没有提供isr，它自动拿到的isr就是乱码，执行后会导致程序跑飞。所以应该先全部关掉，再逐一打开自己需要的中断。一担打开，就要给对应中断提供isr并绑定好。
				
			3.VICnINTSELECT = 0X0，n=0~3
			
				全部设为IRQ普通中断。
			
			4.intc_clearvectaddr(),清理VICnADDR,n=0~3.
						
		(2)中断的使能与禁止
					
			1.先根据中断号判断这个中断属于VIC几，然后用中断源编号减去对应VIC偏移量，得到中断号在对应VIC的偏移量x。用1<<x，写入相应的VIC的INTENABLE/INTENCLEAR寄存器。

		(3)绑定自己实现的isr到VICnVECTADDR
			
			1.弄清楚VICnVECTADDR 和 VICnADDR的区别
			
			2.把中断源对应isr地址丢到中断源对应的VICnVECTADDR寄存器中即可。发生中断时，我们直接到相应的VICnADDR中取isr地址即可。
				
				函数：intc_setvectaddr(unsigned long intnum, void (*handler)(void))
				
				intnum：中断号。
				handler:函数指针。
				
				分析：去中断的使能和禁止类似。计算中断源对应的VICnVECTADDR时，先判断中断属于VIC几，再用对应VICx+(4*中断编号),因为存放的是地址每个相差4字节。
			
		(4)真正的中断程序如何获取isr
			
			1.发生中断时，硬件会自动把isr推向对应VICnADDR寄存器中，所以去取即可。
				
		总结：
			
			第一部分是我们为中断相应而做的预备工作：			
				1.初始化中断控制器
				2.绑定写好的isr到中断控制器
				3.相应中断的所有条件使能
				
			第二部分是硬件产生中断后自动执行isr：
				1.经过异常向量表跳转入IRQ/FIQ的入口
				2.做中断现场保护(start.S)，然后跳入isr_handler
				3.在isr_hander中，先判断哪个VIC中断，然后去对应VIC的ADDR级传奇去取isr来执行即可。
				4.isr执行完，中断现场恢复，直接返回继续执行原来的程序。
		
		10.外部中断
			
			(1)定义
				
				1.内部中断与外部中断
				
					内部中断：中断源来自SoC内部(一般是内部外设，如：串口、定时器等部件)。				
					外部中断：中断源来自SoC外部的设备，通过外部中断对应的GPIO产生的中断。
		
				2.按键
					
					按键在SoC中就使用外部中断来实现。具体实现方法是：将按键电路接到外部中断的GPIO上，并将GPIO配置为外部中断模式。通过按按键改变电路的电压高低，可以出发出发GPIO对应的外部中断。
		
				3.外部中断介绍在UM的2.2.60部分(332)
			
			(2)外部中断触发模式
				
				电平触发：GPIO上电平只要满足条件，就会不停触发中断。分为高电平触发和低电平触发。
				
				边沿触发：分为上升沿触发、下降沿触发和双边沿触发。边沿触发不关心电平常规状态，只关心电平变化的瞬间(从高到低，从低到高)。
				
				分析按键：
					1.如果我们关注的是按键按下和弹起本身，那么应该使用边沿触发来处理。如果关注的是按键按下/弹起之间的那一段时间，那么应该使用电平触发处理。
			
			(3)关键寄存器：CON、PEND、MASK
				
				1.外部中断的主要配置寄存器有3个：EXT_CON、EXT_PEND、EXT_MASK
					
					EXT_CON：配置外部中断的触发方式。即外部电平要怎么变化才能触发中断，外部中断产生需要的条件。
					
					EXT_PEND：中断挂起寄存器，该寄存器每一位对应一个外部中断。当发生中断后，硬件会自动将这个寄存器中该中断对应的位置1。所以处理完中断后要手工将该位置0。
					
					EXT_MASK：各个外部中断的使能/禁止开关。
		
			(4)X210开发板的按键对应的EINT编号：
				
				SW5：GPH0_2 	 EXT_INT[2]
				SW6：GPH0_3		 EXT_INT[3]
				SW7~10：GPH2_0~3 EXT_INT[16] EXT_INT[17] EXT_INT[18] EXT_INT[19]
		
		11.中断方式处理按键编程
			
			(1)外部中断对应的GPIO模式设置
			
				把按键对应的GPIO设置为中断模式(1111)
				
				例：rGPH0_CON |= (oxff<<8);把GPH0_2和GPH0_3设置为中断模式。
				
			(2)中断触发模式设置
				
				设置EXT_INT_n_CON为下降沿中断(0010)
		
				例：rEXT_INT_0_CON &= ~(0xff<<8);先清零
					rEXT_INT_0_CON |= ((2<<8)|(2<<12));设置下降沿中断
		
			(3)中断允许(mask)、清挂起(pend)
		
				1.使能外部中断。
				
					例：rEXT_INT_0_MASK &= ((1<<2)|(1<<3));把1写入对应位使能中断。
		
				2.清挂起	
					
					发生中断后，硬件会自动把相应位置1。但是这个寄存器是写1清0的，所以要相应位置1。
			
					例：rEXT_INT_0_PEND = |= ((1<<2)|(1<<3));清GPH0_2和GPH0_3的挂起。
				
			(4)编写isr(Interrupt Service Routines)
				
				1.中断处理代码，干活的代码
				
				2.清除中断挂起
		
		
		