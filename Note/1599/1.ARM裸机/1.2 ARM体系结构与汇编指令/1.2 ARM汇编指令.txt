 1.2
	15-19汇编指令1
		
		(1)指令与伪指令
			
			1.指令是CPU机器指令的助记符，经过编译后会得到一串1 0组成的机器码，可以由CPU读取执行。
			
			2.伪指令本质上不是指令(只是和指令一起写在代码中)，它是编译器环境提供的，目的是指导编译过程，经过编译后伪指令最终不会生产机器码。
			
		(2)两种不同风格的ARM
			
			1.ARM官方的ARM汇编风格：指令一般用大写、Windows中IDE开发环境(ADS、MDK等)常用。如：LDR R0,[R1]
			
			2.GNU风格的ARM汇编：指令一般用小写字母、linux中常用。如：ldr r0,[r1]
			
		(3)ARM汇编特点：
			
			1.LDR/STR架构
				
				ARM采用RISC架构，CPU本身不能直接读取内存，需要先将内存中内容加载到CPU中通用内存才能被CPU处理。
			
				ldr：load register。指令将内存内容加载入通用寄存器。
				
				str：store register。指令将寄存器内容存入内存空间。
			
				总结：ldr/str组合用来实现ARM CPU和内存数据的交换。
			
			2.8种寻址方式
			
				寄存器寻址		mov r1,r2 (把r2的内容运送到r1，相当于r1 = r2)
				
				立即寻址		mov r0,#0xFF00 (立即数，加#说明是数字。相当于r1 = 0xFF00)	
			
				寄存器移位寻址	mov r0,r1,lsl#3 (把r1左移3位，并把移位后的值赋给r0。相当于r0 = r1*3)
				
				寄存器间接寻址	ldr r1,[r2] (当r2有[]的时候，[r2]表示这个内存的地址在r2中存着，类似一个指针。相当于把r2内存地址中的内容赋给r1，r1 = *r2)
				
				基址变址寻址	ldr r1,[r2,#4] (r2的内存地址加上4，再赋给r2)
			
				多寄存器寻址	ldmia r1!,{r2-r7,r12} (ld，从内存往寄存器加载。r1是内存地址，相当于数组名，数组里面有7个元素。依次往后访问，把元素读取到r2-r7和r12中)
			
				堆栈寻址		stmfd sp!,{r2-r7,lr} (sp只能是堆栈地址，堆栈操作。st为压栈，往栈压。ld为弹栈，往出弹)	
				
				相对寻址		(标号)flag:用来标记后面指令的地址。用b flag来跳转。
								
			3.指令后缀
				
				同一指令经常附带不同后缀，编程不同的指令。经常使用的后缀有：
				
				B(byte)功能不变，操作长度变为8位
				
				H(half word)功能不变，操作长度变为16位
				
				S(sighed)功能不变，操作长度变为有符号
				
					如：ldr、ldrb、ldrh、ldrsb、lsrsh
				
				S(S标志)功能不变，影响CPSR标志位(条件位NZCV)
					
					如 mov和movs。movs r0,#0 会使Z = 1。
			
			4.条件执行后缀
				
				mov r0, r1
				moveq r0, r1 //如果eq后缀成立(上一句代码结果等于0 )，则执行mov r0,r1。如果eq不成立，则这句代码直接作废。
			
				条件后缀执行注意2点：
					
					1.条件后缀是否成立，不是取决于本句代码，而是取决于这句代码的上一句代码运行后的结果。
			
					2.条件后缀决定了本句代码是否被执行，而不会影响上一句和下一句代码是否被执行。 
			
				常用后缀：
					
					eq:		相等
					ne: 	不相等
					cs/hs：	无符号数大于或等于
					cc/lo：	无符号数小于
					
			5.多级指令流水线(CPU自动处理)
			
				ARM使用多级流水线，下图为3级流水线：
					
				ARM	PC			取址	
					PC-4		解码
					pc-8		执行
			
				每句代码一个一个以指令周期周期为单位，一步步经过流水线。流水线越多，CPU性能越好，但流水线被打断后，重启就会很复杂。ARM采用条件执行后缀来解决这个问题。
			
				PC指向正被取址的指令，而非正在执行的指令。
			
				SP5PV210使用13级流水线，ARM11为18级。
				
		(4)数据传输和跳转指令
			
			1.数据处理指令
				
				(1)数据传输指令：mov mvn
				
					mov(move)	
					
						move r1, r0 	在寄存器间数据传递
						move r1, #0xff	将立即数赋值给寄存器
					
					mvn
					
						mnv r1, r0 		按位取反后传递
			
				(2)算数指令：
			
					add	加
					sub	减		sub r2, r0, r1 (r2 = r0 - r1)
					rsb	反减
					adc	
					sbc
					rsc
			
				(3)逻辑运算
				
					and	与
					
					orr	或
					
					eor	异或
					
					bic	位清除，把一些位清零
						
						bic r0,r1,#0x1f	将r1中的数的bit0到bit4(0x1f中为1的位)清零后赋值给0.
			
				(4)比较指令
					
					用来比较两个寄存器的数。比较指令不用加s后缀就可以影响CPSR中的标志位。
					
					cmp		cmp r0, r1 等价于 sub r0, r1，比较r0和r1，如何(r0 = r1)，cprs 的Z位等于1。					
					
					cmn		cmn r0, r1 等价于 add r0, r1, 测试r0与r1是否为反。										
					
					tst		tst r0,#0x8	测试bit_3是否为0。(与bic类似但不同) 判断成立时时候eq为1，ne为0。
					
					teq		teq r0, r1，测试r0与r1是否相等。
				
				(5)乘法指令(少用)
			
					mvl mla umull umlal smull smlal
					
				(6)前导零计数
					
					clz	计算一个数前面有多少个零。
			
			2.cpsr访问指令
				
				cprs寄存器比较特殊，需要专门的指令访问。spsr的s是save的意思，用作普通模式跳转到异常模式时保存cprs状态。
				
				(1)mrs & msr 读写psr(cpsr、spsr)
					
					mrs用来读，msr用来写。
			
					例子：(加工cpsr)
					
							mrs		r0,cpsr
							bic 	r0,r0,#ox1f	//位清除
							orr		r0,r0,#0xd3	//或运算
							msr		r0,cpsr
					
					或者：	msr cpsr_c, #0xd3	只操作mode位。
			
			3.跳转指令
				
				(1) b&bl&bx
					
					b:直接跳转(不打算返回)
					
					bl：branch and link 跳转前把返回地址放回lr中，以便返回。一般用于函数调用(bl + 函数名)。
					
					bx：跳转同时切换到ARM状态，一般用于异常处理的跳转。
			
			4.访存指令
				
				ldr.str & ldm/stm & swp
				
				(1)单字/半字/字节访问	ldr/str
				
				(2)多字批量访问			ldm/stm
			
				(3)swp r1,r2,[r0]		把r0这个内存地址的值读r1，再把r2写到r0的内存地址上。
			
				(4)swp r1,r1,[r0]		相当于寄存器和内存互换数据。
			
			5.立即数
				
				合法立即数和非法立即数
					
				(1)ARM指令是32位的，除了指令标记和操作标记外，本身只能附带很少位的立即数。

				(2)合法立即数就是指经过任意位数的移位后非零部分可以用8位表示的数。
					
					如：0xff, 0x00ff0000，0xf000000f。都是合法立即数		
			7.软中断指令
				
				swi(software interrupt)
				
				用来实现操作系统中系统调用。
					
		(5)协处理器和协处理器指令详解
			
			mcr&mrc
			
			mrc用于读取CP15中的寄存器
			mcr用于写入CP15中的寄存器
			
			1.协处理器	coprocessor	(cooperation processor)
				
				(1)SoC内部另一处理核心，协助主CPU，被主CPU调用执行一定任务。
				
				(2)ARM设计上多达16个协处理器，但是一般SoC只实现其中的CP15(最后一个协处理器)。
			
				(3)协处理器和MMU、cache、TLB等处理有关，功能上和操作系统的虚拟地址映射、cache管理等有关。
			
			2.MRC&MCR的使用方法
				
				mcr{<cond>} p15,<opcode_1>,<RD>,<Crn>,<Crm>,{<opcode_2>}
				
					opcode_1: 	对于cp15永远为0
				
					RD：		ARM的普通寄存器
					
					Crn：		cp15的寄存器。合法值是c0~c15(都是特殊功能寄存器)。
					
					Crm：		一般为c0。
					
					opcode_2: 	一般省略或为0。
					
					
				
				例：
					
					mrc p15, 0, r0, c1, c0, 0
					
					把c1的值读到r0进行操作。
					
		(6)ldm/stm与栈的处理 load/store register mutiple
			
			1.ldr/str每周期只能访问4字节内存，如果需要批量读取、写入内存时太慢。所以需要ldm/stm来批量处理。
			
			例子：	
				
				stmia sp,{r0-r12}	//寄存器写到内存
				
			分析：	
				sp寄存器中放着一个内存地址。以这个内存地址为起始，将r0存入sp指向的内存处，然后地址+4，将r1存入该地址……直到将r12内容放入。
				
			2.八种后缀
				
				ia(increase after)	先传输，再地址+4	
				
				ib(increase before) 先地址+4，在传输
				
				da(decrease after)	先传输，再地址-4
			
				db(decrease before)	先地址-4，再传输

				ea					空增栈。
				
				fa					满增栈。			
				
				ed(empty decrease)	空减栈。
				
				fd(full decrease)	满减栈。	
				
				空栈：栈指针指向空位，每次存入时可以直接存入然后栈指针移动一格。但取出时要先移除一格才能取出。
				
				满栈：栈指针指向栈中最后一格数据，每次存入时需要先移动栈指针一格再存入。取出时可以直接取出，然后再移动栈指针。
				
				增栈：栈指针移动时向地址增加的方向移动的栈。
				
				减栈：栈指针移动时向地址减小的方向移动的栈。
			
			3. 一些符号的作用
				
				(1)!的作用
				
					例子：
						ldmia r0,{r2-r3}
						ldmia r0!,{r2-r3}
						
						分析：
							
							ldmia r0,{r2-r3} ：	把r0里内存地址的值读到r2，再把地址+4，在把新地址里的值读到r3。r0的值不会改变。	
							
							ldmia r0!,{r2-r3}： r0在传递完数据后改变。
						
				(1)^的作用
				
					ldmfd sp!,{r0-r6,pc}
					ldmfd sp!,{r0-r6,pc}^
					
					^的作用	：在目标寄存器中有pc时，会同时将spsr写入到cpsr(一般用于从异常模式返回模式)。
						
	20.ARM汇编伪指令
		
		伪指令和具体的编译器相关。我们使用的是gnu工具链。
			
		(1)gnu汇编中的一些符号
			
			@ 	：汇编用来注释内容的符号。
			
			冒号：以冒号结尾的标号。用来代表(绑定)一个地址，可以直接用标号访问对应地址。相当于c语言中的int a;a会与一个地址绑定。
			
			. 	：代表当前当前指令地址。如：b .(死循环，相当于c语言的while(1).)
			
			#/$ ：在立即数前加#或$。
			
		(2)常见的gnu伪指令
			
			.global_start	@把_start声明为外部链接属性。
			
			.section .text	@指定当前段为代码段。
			
			.ascii(定义字符) 
			.byte 
			.short 
			.long 
			.word(定义字，与long相同)
		
			.quad(定义双字)
			.float
			.string(定义字符串)
			
				例子：	
					
					IRQ_STACK_START:
						
						.word	0x0badc0de
					
					相当于： int IRQ_STACK_START = 0x0badc0de;
						
			.align 4		@以16字节对齐(2的4次方)

			.balignl 16, 0xdeadbeef @对齐 + 填充。
				
				b表示位填充；
				align：表示要对齐；
				l：表示4字节为单位填充；
				16：表示16字节对齐；(与align不同)
				0xdeadbeef：用来填充的原料。
			
			.equ			@类似于C中宏定义
			
		(3)偶尔会用到的gnu伪指令
			
			.end			@代表文件完了
			.include		@包含头文件
			.arm/.code32	@声明以下为arm代码
			.thumb/.code16	@声明以下为thumb指令
			
		(4)重点伪指令
			
			.ldr			@大范围的地址加载指令。把地址加载到寄存器中。
				
				例子：	
					
					ldr指令：	ldr r0, #0xff	
					ldr伪指令：	ldr r0, =0xff
				
				分析：用伪指令ldr时，编译器会帮我们检测立即数是否合法。所以通常使用ldr伪指令。
			
			.adr			@小范围的地址加载指令。
			
			
			
			.adrl			@中等范围的地址加载指令。
			
			
			adr与ldr
				
				adr编译时会被1条sub或add指令替代。
				ldr编译时会被1条mov指令替代或文字池方式处理。
			
				adr总是以PC为基准(相对地址)来表示地址，因此指令本身和运行地址有关，可以用来检测程序当前的运行地址。
				
				ldr加载的地址和链接时给定的地址有关，由链接脚本决定。
			
				所以adr加载的地址在运行时确定；ldr加载的地址在链接时确定。可以通过adr和ldr加载的地址比较来判断当前程序是否在链接时指定的地址运行。
			
			