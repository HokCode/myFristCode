1.5
	5.位置有关(无关)编码
		
		(1)定义
		
			位置无关编码：PIC(position independent code),汇编源文件被编码成二进制可执行程序时，编码方式与位置(内存地址)无关。
		
			位置有关编码：汇编源码编码成二进制可执行程序后和内存地址有关。
			我们在设计一个程序时，会给这个程序指令一个运行地址(链接地址)，而且必须给编译器链接器指定这个地址。最后得到的二进制程序理论上是和这个地址有关的，这个程序将来被执行时必须放在当时编译链接给定的这个地址(链接地址)下才行，否则不能运行。
		
			但是有个别特别指令可以和地址无关，在实际运行时可以放在任何地方都能正常运行。大部分指令是位置有关编码。
			
			分析：相比来说，位置无关代码适应性更强。但是位置无关代码有一些限制，不能完成所有功能，所以不得不使用位置有关码。
		
		(2)链接地址和运行地址：可以相同也可以不同
			
			1.概念
				
				链接地址：链接时指定的地址(指定方式为：makefile中用-Ttext，或者链接脚本)
				
				运行地址：程序实际运行时地址(指定方式为：由实际运行时被加载到内存的哪个位置为准)
				
			2.对于位置有关代码来说，最终执行时的运行地址和编译链接时给定的链接地址必须相同。
		
				例子：
					
					裸机程序的makefile中，用 -Ttext 0x0 来指定链接地址是0x0。程序员认为这个程序将来就会放在0x0这个内存地址去运行。但实际上我们运行时的地址是0xd0020010。
					
		(3)回顾S5PV210的启动过程
				
			(1)三星推荐的启动方式：bootloader必须小于96kb并大于16kb。

			(2)uboot实际启动的方式：uboot大小随意。启动过程：先开机上电后BL0运行，BL0会加载外部启动设备中的uboot的前16kb(BL1)到SRAM中运行(与三星相同)，BL1运行时会初始化DDR，然后把整个uboot搬运到DDR中，再用一句长跳转指令从SRAM中跳转到DDR中执行uboot直到uboot完全启动。
			
		(4)为何需要重定位
			
			1.链接地址和运行地址有时候必须不相同，而且不能全用位置无关码。这时必须用重定位。
			
			拓展：
				
				分散加载：把uboot分成2部分(BL1和整个uboot)，两部分分别指定不同的链接地址。启动时将两部分加载到不同地址(BL1加载到SRAM，整个uboot加载到DDR)，这样不用重定位也能启动。
			
	6.链接脚本
		
		(1)运行地址	
			
			运行时的地址是运行时决定的，在编译链接时是无法确定运行的地址的。
		
		(2)链接地址	
			
			链接地址是由程序员在编译链接过程通过makefile中 -Ttext xxx 或者在链接脚本中指定的。程序员通过预知自己程序的执行要求，会有一个期望的执行地址，并会用这个地址来做链接地址。
		
				分析：
					
					1.linux中的应用程序。当gcc hello.c -o hello	这时使用默认的链接地址就是0x0，因为应用程序运行在操作系统的一个进程中，在这个进程中这个应用程序独享4G的虚拟地址空间。所以应用程序都可以链接到0地址，每个进程都是从0地址开始。 
		
					2.210的裸机程序。运行地址由我们下载时决定，下载时下载到0xd0020010，所以就从这里开始。理论上程序员编译链接时一个将地址指定到0xd0020010，但实际上我们在编译裸机程序中都是用位置无关码PIC，所以链接地址可以是0。
		
		(3)从源码到可执行程序的步骤：预编译、编译、链接、strip
		
			预编译：预编译器执行。
			
			编译  ：编译器来执行，把源码.c .s变成机器码.o。
			
			链接  ：链接器来执行。把.o文件的各函数(段)按照一定规则(链接脚本来指定)累计起来，形成可执行文件。
		
			(可选步骤)			
			strip：把可执行程序中的符号信息拿掉，以节省空间。
			
			objcopy：由可执行文件生成可烧录的镜像bin文件。
		
		(4)程序段：代码段、数据段、bss段(ZI段)、自定义段
			
			1.段就是程序的一部分，把整个程序分成一个一个的段，给每个段起一个名字，然后在链接时可以用这个名字来指示这些段。还可以在链接脚本中用段名让段站在合适的位置。  
		
			2.段名分类
				
				(1)编译器链接器内部定好的，先天性的名字
					
					代码段：(.text段)，也叫文本段。函数编译后生成的东西。
					
					数据段：(.data段)。
					
					bss段 ：(zero initial)ZI段。
				
				(2)程序员自己指定的，自定义的段名。
		
					段的属性和特征都由程序员自己定义。
				
			(5)链接脚本作用
				
				1.链接脚本是一个规则文件,是程序员用来指挥链接器工作的。链接器会参考链接脚本中规定的规则来处理.o文件中的段，将其链接成一个可执行程序。
		
				2.链接脚本关键内容：
					
					(1)段名
					
						链接器定位段的根据。
					
					(2)地址
						
						作为链接地址的内存地址。存放段的地方。	
					
				3.链接脚本解读
					
					SECTIONS{}:这是整个链接脚本。
					
					. 点号 	  :在链接脚本中代表当前位置。
		
					= 等号    :赋值符号。
		
					.text :{
						start.o
						* (.text)
					}
		
	7.实战演练
		
		(1)重定位练习：在SRAM中将代码从0xd0020010重定位到0xd0024000
			
			1.通过链接脚本将代码链接到0xd0024000
				
			2.在bin文件下载时将文件下载到0xd0020010 
			
				分析1、2：把代码链接地址设置为0xd0024000，如果这段代码将来不在这个位置执行就会出事(位置无关码PIC除外)。所以需要重定位：在PIC执行完之前(在代码中第一句位置有关码执行之前)，必须将整个代码搬移到0xd0024000位置去执行。
			
			3.代码执行时通过代码前段的少量位置无关码将整个程序搬移到0xd0024000
		
			4.使用一个长跳转跳转到0xd0024000处的代码继续执行，重定位完成。
		
				分析：当执行完代码重定位后，实际上在SRAM中有2份代码的镜像(一份是0xd0020010处开头的，另一份是重定位代码复制到0xd0024000处开头的)。通过长跳转ldr pc, =led_blink，就会执行0xd0024000处开头的那一份代码。 (如果用bl led_blink就是bl指令实现短跳转)
		
				当链接地址和运行地址相同时，短跳转和长跳转实际效果相同；但是当链接地址和运行地址不同时，短跳转实际执行的是运行地址处的那一份，而长跳转执行的是链接地址处的那一份。
		
			总结：重定位实际就是在运行地址处执行一段位置无关码PIC，让这段PIC(重定位代码)从运行地址处跳转把整个程序镜像拷贝一份到链接地址处，最后使用一句长跳转指令从运行地址处跳到链接地址处去执行同一个函数(如 上题的led_blink)。这样就实现了重定位之后的无缝链接。
		
		(2)实战代码
			
			1.adr与ldr伪指令的区别
				
				adr指令加载符号地址时，加载的是运行地址。
				ldr指令加载符号地址时，加载的是链接地址。
				
					adr  r0, _start		//r0,运行地址	
					ldr  r1, =_start	//r1,链接地址
					
					ldr  r2, =bss_start	//重定位结束地址
					
					cmp r0, r1
					beq clean_bss		//如果相等，不需要重定位。
		
			2.重定位
				
				(1)重定位就是汇编代码中的copy_loop函数，代码的作用是使用循环结构来逐句复制代码到链接地址。
					
					如上题：复制的源地址时SRAM的0xd0020010，复制的目标是0xd0024000。
		
						ldr r3, [r0], #4	//源，  r3=[r0],[r0]=[r0]+4
						str r3, [r1], #4	//目标，[r1]=r3,[r1]=[r1]+4。
					
						cmp r1, r2			//判断是否结束
						bne copy_loop		
					
						分析：重定位只需复制代码段和数据段。bss段不需要重定位。
								
			3.清bss段
				
				(1)清bss段是为了防止内存是“脏”内存。一般c语言编译器和链接器会自动帮我们清bss段，但是在代码重定位后，需要自己清除bss段。
		
					ldr r0, =bss_start
					ldr r1, =bss_end
					cmp r0, r1			//判断是否有全局变量。
					beq run_on_dram
					mov r2, #0
				clear_loop
					str r2, [r0], #4    //把r2(0)写到[r0]的内存地址。然后[r0]=[r0]+4。
					cmp r0, r1
					bne clear_loop
				
					清理完bss段后重定位就结束了。
			
			4.长跳转
				
				(1)当前运行地址还在0xd0020010(运行地址)开头的代码中运行着。	
				
				(2)此时SRAM有2份代码。	
				
				(3)长跳转
					
					run_on_dram:
						ldr pc, =led_blink
		
			拓展：	
				
				ldr加载时，如果目标寄存器是PC就叫长跳转，如果目标寄存器是r1就叫长加载。
					
					ldr r1,	[r1, #20]
					ldr pc, [pc, #20]
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		