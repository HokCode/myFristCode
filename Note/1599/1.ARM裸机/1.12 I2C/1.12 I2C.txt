1.12
	
	1.I2C通信定义
		
		(1)物理通信线：SCL+SDA
			
			SCL：时钟线(serial clock)，传输CLK信号，一般是I2C主设备向从设备提供时钟的通道。			
			SDA：数据线(serial data)，通信数据都通过SDA线传输。
			
		(2)通信特征：串行、同步、非差分、低速率
		
			1.I2C属于串行通信，所有的数据以位为单位在SDA线上串行传输。
			
			2.同步通信工作在同一个时钟下，一般是通信的一方通过一根时钟线传输自己的时钟给另一方。所以同步通信有个显著特征是：通信线中有CLK。
			
			3.非差分(电平)。I2C通信双方速率不高，距离近，所以用电平信号。
			
			4.I2C一般是用在同一板子上的2个IC之间的通信，而且用来传输的数据量不大，所以一般只有几百k的通信速率，不同I2C芯片的通信速率可能不同。
		
		(3)突出特征1：主设备+从设备
			
			1.I2C通信时，通信双方地位是不对等的，分为主设备和从设备。主设备发起并主导通信，从设备只是按照I2C协议被动地接收通信并相应。
		
			2.主、从设备是由通信双方来定的。一个芯片可以只当其中之一，也可以两者都是(软件配置)。
		
		(4)突出特征2：可以多个设备挂在一条总线上(从设备地址)
			
			1.I2C通信可以1对1、1对多。
			
			2.主设备负责调度总线，决定某一时间和哪个设备通信。同一时间只能有一个主设备和一个从设备通信，其他从设备先"冬眠"。
		
			3.每个I2C从设备在通信中都有一个I2C的从设备地址，主设备在通信中通过地址来判断自己要找的从设备。每个从设备的地址是电路板上唯一的。
		
		(5)主要用途
			
			主要用在SoC和周边外设之间的通信(典型的如：EEPROM、电容触摸IC、各种传感器(sensor)等)
		
	2.I2C通信时序
		
		(1)时序定义
			
			时间顺序，指在通信线上按照时间顺序发生的电平变化，以及这些变化对通信的意义。
		
		(2)I2C的总线空闲状态、起始位、结束位
		
			1.I2C总线包括1个主设备，n(n>=1)个从设备。总线上有2种状态：
		
			  空闲：没有从设备与主设备通信，总线空闲。
			  忙态：其中一个从设备正与主设备通信，此时总线被占用。
		
			2.通信分为一个个周期，两个相邻的通信周期是空闲态。每一个通信周期由一个起始位开始，一个结束位结束，中间是本周期的通信数据。
			
			3.起始位是一个时间段。在这段时间内，SCL线维持高电平，同时SDA线发生一个从高到低的下降沿。 			  
			  结束位也是一个时间段。在这段时间内，SCL线维持高电平，同时SDA线发生一个从低到高的下降沿。 
		
		(3)I2C数据传输格式(数据位&ACK)
			
			1.主设备在每个通信周期会先发8位的从设备地址到总线，其中7位表示从设备地址，1位表示主设备要Write还是Read。
		
			2.主设备是以广播形式发送的，所有挂在总线上的从设备都能收到。从设备收到地址后会和自己的设备地址比较，判断相等。
		
			3.发送方发送一段数据后，接收方需要回应一个ACK，大小为1个bit位。ACK只能表示2个意思：表示收到数据，有效响应；表示未收到数据，无效响应。
		
			4.在某一个通信时刻，主设备和从设备只能有一个在发(向总线写)，另一个在收(从总线读)。不能同时发或同时收。 
		
		(4)数据在总线上的传输协议
			
			1.字节是I2C通信的基本数据单位，每次传输的有效数据都是1个字节。
		
			2.主设备发送完数据后，按照协议从设备需要发送ACK给主设备，所以此时主设备必须释放总线(把总线置为高电平，类似于总线空闲状态)。如果从设备没有拉低总线或拉低失败，则表示接收失败。
			
	3.S5PV210的I2C控制器
		
		(1)结构框图
			
			1.时钟部分：时钟来源是PCLK_PSYS，经过内部分频最终得到I2C控制器的CLK，通信中这个CLK会通过SCL线传给从设备。
			
			2.I2C总线控制逻辑(I2CCON、I2CSTAT两个寄存器)，主要负责产生I2C通信时序。实际编程中要发送起始位、停止位、接收ACK都是通过这两个寄存器。
		
			3.移位寄存器(shift register)，将代码中要发送的字节数据变成1个位1个位来丢给SDA线上去发送/接收。
		
			4.地址寄存器+比较器(Comparator)，本I2C控制器做从设备时使用。
			
		(2)系统分析I2C的时钟
			
			1.I2C时钟源头来源于PCLK(PLCK_PSYS，等于65MHz)，经过两级分频后得到。
			
			2.第一级分频是I2CCON的bit6，可以得到一个中间时钟I2CCLK(0为I2CCLK = PCLK /16，1为I2CCLK = PCLK /512)。
		
			3.第二级分频是得到最终I2C控制器工作的时钟，以上面的到的中间为时钟来源。在I2CCON的bit0~bit3。
		
		(3)护腰寄存器：I2CCON、I2CSTAT、I2CADD、I2CDS
		
				I2CCON+I2CSTAS：用来产生通信时序和I2C接口设置。
					
					I2CCON bit4：
					write：不能写1(N/A)；写0表示清除中断挂起，继续进行通信。
					read：1表示中断挂起；0表示中断没有挂起。
					
					I2CSTAS bit5：
					write：写1，起始位START;写0，停止位STOP。
					
					
				I2CADD：用来写自己的slave address(从设备地址)。
				I2CDS：存放发送/接收的数据。
		
	4.X210板载gsensor介绍
		
		(1)原理图信息
		
			1.gsensor供电由PWMOUT3引脚控制。当PWMOUT3输出低电平时，gsensor无电不工作；当输出高电平时，gsensor才会工作。
		
			2.gsensor的SDA和SCL接的是S5PV210的I2C端口0。
		
			3.将来编程时要先初始化相关的GPIO。
		
		(2)gsensor介绍
			
			1.用在手机(游戏)、平板、智能手表(计步器)等设备上。获取一些运动的方向性信息用来给系统作为输入参量。
		
			2.重力加速度传感器、地磁传感器、陀螺仪等三个传感器结合起来，都是用来检测运动速度与方位。
		
			拓展：一般传感器的接口有2种：模拟接口和数字接口。
				
				模拟接口：用接口电平变化来输出。如：压力传感器，压力不同导致其电平在一定范围内变化。SoC需要用AD接口来对接传感器，对其数据进行AD转换得到数字压力值。
		
				数字接口：在模拟接口传感器的基础上，内部集成了AD。通过一定的总线接口协议(I2C)，直接输出一个数字值的参数。SoC可直接通过总线接口初始化，读取传感器输出的参数。KXTE9属于这种。 
		
		(3)I2C从设备的设备地址
			
			1.KXTE9的I2C地址固定为0b0001111。
		
			2.I2C从设备地址本身是7位的，但在I2C通信中，发送从设备地址时实际发送了8位。其中高7位对应I2C从设备的7位地址，最低一位存放的是R/W信息。
			
			  主设备写从设备读(对应0)，主设备读从设备写(对应1)。
		
			3.对于KXTE9，主设备(SoC)发给gsensor信息时，SAD应该是00011110(0x1E)。读取时为：00011111(0x1F)。
		
		(4)I2C从设备的通信速率
			
			1.I2C协议本身属于低速协议，通信速率不能太高。
			
			2.编程时最终的通信速率只要都小于主设备和从设备本身的最高通信速率即可。
		
			3.一般只能做从设备的sensor芯片本身I2C的通信速率都比较低。如KXTE9为400KHz。
		
	5.I2C通信代码分析1
	
		(1)I2C控制器初始化：s3c24xx_i2c_init
			
			初始化做的事情：初始化GPIO，设置IRQEN和ACKEN，初始化I2C时钟

		(2)I2C控制器主模式开始一次读写：s3c24xx_i2c_message_start

		(3)I2C控制器主模式结束一次读写：s3c24xx_i2c_stop


	6.I2C通信代码分析2
		框架分析：我们最终目的是通过读写gsensor芯片的内部寄存器来得到一些信息。根据gsensor的规定我们需要按照一定的操作流程来读写gsensor的内部寄存器，这是一个层次（可叫做传输层、协议层、应用层）；
		我们要按照操作流程去读写寄存器，就需要考虑I2C接口协议（这就是所谓的物理层，本质就是I2C的那些时序）。此时主机SoC有控制器就考虑控制器的寄存器，没控制器时要自己软件模拟时序。
		
		协议层的代码主要取决于gsensor芯片；物理层代码主要取决于主机SoC。

		gsensor写寄存器：gsensor_i2c_write_reg
		gsensor读寄存器：gsensor_i2c_read_reg
		gsensor编程：gsensor_initial等	
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		