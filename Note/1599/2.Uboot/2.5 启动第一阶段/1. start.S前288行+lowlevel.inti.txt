1.start.S的引入
	
	(1)u-boot.lds中找到start.S入口
		
		1.在C语言中整个项目的入口就是main函数。

		2.在uboot中有汇编阶段参与，所以不能直接找main.c。整个程序的入口取决于链接脚本中ENTRY声明的地方。所以_start所在文件时整个程序的其实文件，_start所在处的代码是整个程序的起始代码。

	(2)利用SourceInsight(SI)寻找_start所在文件

		1.查找_start功能。
		
		2.如果已经知道_start在哪个文件，可在项目文件列表直接搜索文件。
	
2.start.s解析1
	
	(1)头文件包含解析
		
		#include <config.h>
			
			1.config.h在配置过程中自动生成。(mkconfig脚本)
			2.config.h中的内容为#include <configs/x210.sd.h>
			3.x210.sd.h中有很多宏，是整个uboot移植时的配置文件。
		
		#include <version.h>
		
			1.version中包含了include/version_autogenerated.h，这个头文件就是配置过程中自动生成的。
			
			2.version_autogenerated.h里面的内容是
			#define U_BOOT_VESION "U-BOOT 1.3.4"，字符串中的版本号来自makefile的配置。
			
		#if defined(CONFIG_ENABLE_MMU)
		#include <asm/proc/domain.h>

			1.CONFIG_ENABLE_MMU在X210_sd.h中有定义，所以执行#include语句。
			
			2.asm目录不是uboot中的原生目录，它是配置时创建的符号链接，实际指向的是asm-arm；pro同理实际指向pro-armv。(mkconfig脚本)
		
				分析：符号链接是为了可移植性。如果直接用asm-arm/pro-armv，那start.S就会和CPU架构(硬件)有关，可移植性就会变差。

3.start.s解析2
	
	(1)启动代码的16字节校验头
	
		#if defined(CONFIG_EVT1) && !defined(CONFIG_FUSED)
			.word 0x2000
			.word 0x0
			.word 0x0
			.word 0x0
		#endif

		1.四个.word相当于定义了一个int类型数组，里面有4个元素共16字节。
	
		2.在SD卡启动和Nand启动等镜像开头需要16字节校验头，在裸机时我们利用了mk210image.c给原镜像前加16字节校验头。

		3.uboot在start.S中的开头位置放了16字节填充占位，但这16字节的内容是不对的。后面的代码会去计算校验和然后重新填充。在uboot/sd_fusing/mkbl1中的代码会完成计算工作。

	(2)异常向量表的构建
			
		_start: b	reset				复位
		ldr	pc, _undefined_instruction	未定义异常	
		
		1.异常向量表是硬件决定的。每种异常都应该被处理，但在uboot中并未非常细致地处理各种异常。

		2.复位异常处的代码是：b reset，因此在CPU复位后执行的有效代码是reset处的代码。

	(3)deadbeef(85行)
		
		.balignl 16,0xdeadbeef：伪指令，让内存以16字节为单位对齐，如果没对齐的就用0xdeadbeef数据来填充。

		注意：
			1.0xdeadbeef是一个十六进制的数字，不是字符串。

			2.对齐访问：可以调高效率；有的硬件会要求对齐。

	(4)TEXT_BASE(100行)
		
		1.uboot链接时指定的链接地址，值为0xc3e00000。

		2.源代码中和配置Makefile中很多变量是可以互相运送的，有些符号的值可以从Makefile中传递到源代码中。

4.start.s解析3
	
	(0)uboot在ddr中的物理地址(PHY_BASE)
		
		_TEXT_PHY_BASE:
			.word	CFG_PHY_UBOOT_BASE 
		分析：
			1.CFG_PHY_UBOOT_BASE为0x33e00000

	(1)reset复位代码(start.S的141行)

		msr	cpsr_c, #0xd3 @ I & F disable, Mode: 0x13 - SVC
	
			1.设置cpsr程序状态寄存器，0xd3(11010011)。即设置为禁止FIQ和IQR中断，ARM状态，SVC模式。

			2.ARM CPU在复位时默认进入SVC模式，但为了保险，会软件再设置一次。
	
	(2)设置L2、L1cache和MMU(start.S的200~221行)
		
		1.bl disable_12cache	//禁止L2 cache
		2.bl set_l2cache_auxctrl_cycle	//L2 cache相关初始化
		3.bl enable_l2cache		//使能L2 cache
		4.Invalidate L1 I/D		//刷新L1 cache/icache/dcache
		5.关闭MMU
	
		分析：以上5步都是和CPU的cache和mmu有关。

	(3)识别并暂存启动介质选择
		
		/* Read booting information */
		1.在X210内部有一个寄存器是根据硬件选择的启动方式自动设置值的，即寄存器的值反映真正的启动介质。(start.S的225行)
		
		2.代码中可通过读取寄存器的值来确定当前选择的启动介质。

		3.start.S的260行中，如果是SD启动会执行给r3赋值#BOOT_MMCSD(0x03)，以便以后使用。

	(4)设置栈(SRAM中的栈)并调用lowlevel_init(start.S的284行)

		ldr	sp, =0xd0036000
			
			1.因为DDR还未被初始化，代码还在SRAM中运行，所以在SRAM中设置栈。
			
			2.在调用函数前初始化栈，主要原因是调用函数时BL会将返回地址存储到LR中，但LR只有一个，当需要第二层调用函数时，需要先把LR先前记录的地址先存入栈。

5.start.s解析4
		
	分析lowlevel_init函数
	
	push {lr}：压栈。把lr记录的地址存入栈中。
	 
	(1)检查复位状态(lowlevel_init函数 44行)
			
		1.复杂CPU允许多种复位情况。如：冷上电、热启动(休眠启动).
			
		2.在复位代码中需要检测复位状态，从而判断CPU在哪种情况。因为当冷上电时，DDR需要初始化才能使用；但在热启动或低功耗状态下的复位就不需要。  
			
	(2)IO状态恢复(lowlevel_init函数 54行)
			
	(3)关闭看门狗(lowlevel_init函数 61行)
			
	(4)一些外部SRAM和SROM相关GPIO设置(lowlevel_init函数 66行)
			
	(5)供电锁存(lowlevel_init函数 100行)	
			
	注意：
		1.函数所在的路径要选择正确。如：lowlevel_init函数真正的地方是在：/uboot/board/samsumg/x210/lowlevel_init.S中。	
		
		2.在lowlevel_init.S函数的前100行都是做一些准备工作。
	
6.start.s解析5
		
	分析lowlevel_init函数
		
	(1)判定当前代码执行位置是在SRAM中还是在DDR中(lowlevel_init函数 110行)
		
		原因1：uboot的前一部分BL1在SRAM中有一份，在DDR中也有一份。如果是冷启动，那么当前代码应该是在SRAM中运行BL1；如果是低功耗的复位，那么当前代码应该是在DDR中运行。
			
		原因2：比如在lowlevel_ini.S中，如果只是低功耗复位，那初始化DDR和时钟初始化的工作都不用重复做了。
		
		bic	r1, pc, r0
		ldr	r2, _TEXT_BASE
		bic	r2, r2, r0
		cmp r1, r2
			将pc某些特殊bit位清0，特殊bit位为r0为1的bit位。把链接地址_TEXT_BASE加载到r2。然后再把r2的对应位清0。比较r1、r2。
				
			分析：因为pc位不在链接地址首部，所以先把pc的地址和链接地址共同清除4KB再比较。相等证明在DDR中。
			
		
		beq 1f(lowlevel_init的第115行)	
		
			1代表一个符号；f代表向后找(b代表向前找)。
	
	(2)system_clock_init(lowlevel_init函数 205行)
		
		1.此时钟初始化过程与裸机中的初始化类似，但是使用汇编代码写的，而且更加完整。
	
		2.在x210_sd.h中300行到428行中，都是和时钟相关的配置值(宏定义)。
	
7.start.s解析6
	
	分析lowlevel_init函数
	
	(1)mem_ctrl_asm_init(lowlevel_init函数 207行)
			
		1.该函数用于DDR初始化。函数位置在uboot/cpu/s5pc11x/s5pc110。
		
		2.与裸机中初始化DDR是同一代码。但参数DMC0_MEMCONFIG_0不同，在裸机配置值为0x20E01323；在uboot中配置为0x30F01313。
		 在裸机中DMC0的256MB内存地址范围为0x20000000~0x2FFFFFFF；
		 在uboot中DMC0的256MB内存地址范围为0x30000000~0x3FFFFFFF。
		
		3.分析移植的uboot可以看出，DMC0上允许的地址范围是0x20000000~0x3FFFFFFF(共512MB)。SoC允许给实际的256MB物理内存挑选地址范围。
	
		总结：在uboot中，可用的物理地址范围为：0x30000000~0x4FFFFFFF，其中0x30000000~0x3FFFFFFF为DMC0，0x40000000~0x4FFFFFFF为DMC1。
	
		注意：	
			1.分析代码是要留意条件编译的条件，配置头文件中有在不同时钟配置下的内存配置值，这能满足不同时钟需求的客户。
	
	(2)uart_asm_init(lowlevel_init函数 211行)
		
		1.初始化串口。
		
		2.初始化完毕后，通过串口发送大写O，有调试作用。(uart_asm_init函数 430行)
	
	(3)tzpc_init(lowlevel_init函数 213行)
	
		1.trust zone初始化。
	
	(4)POP {pc}以返回
	
		1.返回前通过串口打印'K'。
	
		2.lowlevel.init.S执行完如果没错串口会打印出'OK'字样。
	
lowlevel_init.S总结
	
	做过的工作
		
		检查复位状态、IO恢复、关看门狗、开发板供电锁存、(判断代码位置)、时钟初始化、DDR初始化、串口初始化并打印'O'、tzpc初始化、打印'K'。

		
