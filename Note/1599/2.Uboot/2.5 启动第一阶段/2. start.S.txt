8.start.S解析7

	(0)再次设置开发板供电锁存。(start.S第292行)		
		
		1.代码移植时尽量添加代码而不删除代码。
		
	(1)再次设置栈(DDR中的栈)(start.S第297行)
	
		1.这次设置栈与第一次设置不同，本次DDR已被初始化，所以要把栈移到DDR，内存更大，更有保障。
		
		ldr	sp, _TEXT_PHY_BASE(代码段物理基地址)
		
		2.实际栈地址_TEXT_PHY_BASE在x210_sd.h中被设置为0x33e00000,与uboot紧挨着。因为ARM默认的栈是满减栈，所以不怕栈内容踩到uboot。
			
	(2)再次判断代码位置(SRAM or DDR)

		1.这次是为了判断是否进行uboot的重定位relocate。

9.uboot重定位详解(start.S第312行)
			
	(1)0xD0037488这个内存地址在SRAM中，地址中的值是硬件根据SD卡在哪个通道中自动设置的。如：从SD0通道启动时，值为0xEB000000；从SD2通道启动时，值为0xEB200000。

	(2)在start.S的260行确定了从MMCSD启动，在278行将#BOOT_MMCSD写入INF_REG3寄存器中存储着。后面在322行读出数据比较，确定从MMCSD启动，跳转到mmcsd_boot函数去执行(343行)。

	(3)调用movi_bl2_copy函数完成重定位，函数在uboot/cpu/s5pc11x/movi.c中，是一个C语言函数。

	(4)分析movi_bl2_copy函数：
		
		copy_bl2(2, MOVI_BL2_POS, MOVI_BL2_BLKCNT, CFG_PHY_UBOOT_BASE, 0)
		
		2：					表示通道2。
		MOVI_BL2_POS：		开始扇区号。
		MOVI_BL2_BLKCNT：	读取扇区数。
		CFG_PHY_UBOOT_BASE：0x33e00000。
		
10.start.S解析9——引入虚拟地址
	
	(1)虚拟地址和物理地址
	
		1.物理地址：物理设备设计生产时赋予的地址。如裸机中的寄存器的地址就是CPU设计时指定的。物理地址是硬件编码的，设计生产时已经确定好，不能修改。

		分析：物理地址只能通过查询数据手册获得并操作，不够灵活。

		2.虚拟地址：软件操作和硬件被操作之间增加一个层次，叫做虚拟地址映射层。映射层建立一个虚拟地址到物理地址的映射表。

	(2)MMU单元(memory management unit)
		
		1.内存管理单元。MMU实际是一个SoC中一个硬件单元，主要功能是实现虚拟地址到物理地址的映射。
		
		2.MMU单片在CP15协处理器中进行控制，所以操控MMU就是对cp15协处理器的寄存器进行编程。

	(3)地址映射的额外收益1：访问控制
	
		1.在管理上对内存进行分块，每块进行独立的虚拟地址映射。每一块的映射关系中同时还实现了访问控制(可读、可写、只读、只写、不可访问等)。

	(4)地址映射的额外收益2：cache
		
		1.cache的工作和虚拟地址映射有关。
		
		2.cache是快速缓存，速度比CPU慢但比DDR快。CPU会把一些DDR常用的内用事先读取缓存在cache中，找东西时先找cache，没有再找DDR。

11.start.S解析10——cp15寄存器设置
	
	(1)使能域访问(cp15的c3寄存器)
	
		(start.S第361行)
		
		1.cp15协处理器内部有c0到c15共16个寄存器，每个都有自己的作用，可通过mrc和mcr指令来访问这16个寄存器。
	
		2.域访问和mmu的访问控制有关，c3寄存器在mmu中的作用就是控制域访问。

	(2)设置TTB,translation table base(cp15的c2寄存器)
	
		(start.S第366行)
		
		1.转换表基地址。转换表是建立一套虚拟地址映射的关键，分为表索引和表项。表索引对应虚拟地址，表项对应物理地址。

		2.真正的转换表由若干个转换表单元构成，一个转换表单元能对一个内存块进行虚拟地址转换，总体的转换表负责整个内存空间(0~4G)的映射(映射中规定内存映射和管理要以块为单位，块的大小不定)。

		3.建立虚拟地址映射的主要工作时建立转换表。

		4.转换表放置在内存中，放置的起始地址在内存中要求xx位(1MB)对齐。将TTB设置到cp15的c2寄存器，mmu工作时会自动去查转换表。

	(3)使能MMU(start.S第374行)
		
		1.cp15的c1寄存器的bit0位，0：禁止MMU；1：使能MMU。

	(4)分析转换表
		
		1.通过符号查找，找到转换表在lowlevel_init.S文件的593行。

12.start.S解析10——虚拟地址转换表(lowlevel_init.S第593行)
	
	(1)宏观上理解转换表：整个转换表可以看做是一个int类型的数组，数组中一个元素就是一个表索引和表项的单元。数组中的元素小标是表索引，元素值是表项。
	
	(2)ARM的段式映射中长度为1MB，因此一个映射单元只能管1MB内存。整个4G范围内需要4096个映射单元，所以这个数组的元素个数为4096。实际操作时，会把4096个单元分成几部分，然后每部分用for循环做相同处理。
	
	
	(3)几个命令介绍
	
		.macro xx .endm：汇编中声明宏的指令。
	
		.rept xx .endr：汇编中的for循环。
	
	分析转换表结论：
		
		DRAM有效范围：
		DMC0：0x30000000~0x3fffffff
		DMC1：0x40000000~0x4fffffff
		1.uboo虚拟地址映射只是把虚拟地址的c0000000~d0000000的265MB映射到DMC0的30000000~40000000的256MB物理内存上，其他的虚拟地址都与对应的物理地址相同。
	
		2.所以配置时将链接地址设置为c3e00000，因为这个是虚拟地址，会被映射到33e00000这个物理地址。
	
	注意：MMU开启后，所有的地址都是虚拟地址。
	
13.start.S解析11
	
	(1)第三次设置栈(start.S第388行)
		
		1.本次设置栈的目的是为了让其在更安全，与uboot更近的地方。
	
		2.uboot将栈设置在uboot起始地址上方2MB-0x1000的地方，这样安全的栈空间是：2MB-0x1000-uboot大小。大概是1.8MB的内存。
	
	(2)清理bss段(start.S第400行)
	
		1.表示bss段的开头和结尾的符号是从链接脚本u-boot.lds得到的。
		
	(3)ldr pc, _start_armbootstart.S第411行)
		
		1.uboot第一阶段的最后一指令。start_armboot是uboot/lib_arm/board.c中，是一个C语言函数。这个函数就是uboot的第二阶段，uboot使用一个远跳转跳转到ddr中的第二阶段。
	
	总结uboot第一阶段做的工作：
		
		1.构建异常向量表
		2.设置CPU为SVC模式
		3.关看门狗
		4.开发板供电电路置锁
		5.时钟初始化、DDR初始化
		6.串口初始化并打印"OK"
		7.重定位
		8.建立映射表并开启MMU
		9.跳转到第二阶段
	
	

