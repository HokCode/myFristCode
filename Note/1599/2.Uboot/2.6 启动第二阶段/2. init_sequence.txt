6.armboot函数解析4——init_sequence

	(1)interrupt_init()

		1.此函数实际初始化的是timer4。

		2.210共有5个pwm定时器，其中timer0~timer3都有一个对应的pwm信号输出的引脚。timer4没有引脚，是用过做计时的。

		3.timer4计时时需要设置两个寄存器：TCNTB4、TCNTO4。TCNTB4用于定次数；TCNTO4是程序员用来读取时间的有没有减到0的。

		4.timer4定时器没有中断支持，所以CPU只能通过轮询方式不断读取TCNTO寄存器来确定定的时间到了没有。

		5.interrupt_init函数将timer4设置为定时10ms。关键部分就是get_PCLK函数获取系统设置的PCLK_PSYS时钟频率，然后设置TCFG0进行分频，计算出设置为10ms需要的值写入TCNTB，最后设置autoreload模式并开启定时器。

	(2)env_init
		
		1.环境变量有关的初始化。因为uboot支持不同的启动介质，不同介质存取操作env的方法都是不同的，所以有很多env_xxx.c的文件。

		2.x210是iNand启动，所以是env_movi.c。

		3.该函数对内存里那份uboot中的env做了基本的初始化(判定里面有没有能用的env)。当前还没进行环境变量从SD卡到DDR的relocate，所以当前环境变量是不能用的。

		4.在arm_boot第776行中env_relocate才进行环境变量的relocate。relocate之后才能从DDR中取环境变量。

7.armboot函数解析5——init_sequence

	(1)init_baudrate
		
		1.初始化串口通信的波特率。
	
		2.getenv_r函数用来读取环境变量baudrate(读取到的是字符串类型)。然后用simple_strtoul函数将字符串转成数字格式的波特率。

			getenv_r("baudrate", tmp, sizeof(tmp))
			
		3.baudrate初始化的规则是：先去环境变量读取"baudrate"这个环境变量的值。如果读取成功则把这值作为环境变量赋给gd->baudrate和gd->bd->bi_baudrate；否则读取不成功字使用x210_sd.h中的CONFIG_BAUDRATE的值作为波特率。

	(2)serial_init
		
		1.初始化串口。使用的是uboot/cpu/s5pc11x/serial.c中的serial_init函数。

		2.分析后可知，serial_init函数什么都没做，因为串口在汇编时已经被初始化过了。

8.armboot函数解析6——init_sequence

	(1)console_init_f(控制台第一阶段初始化)
		
		1._f后缀表示第一阶段初始化；_r后缀表示第二阶段初始化。因为有时初始化不能一次完成，要分成两部分。consle_init_r在start_armboot第826行。

		2.console_init_f在uboot/common/console.c中，在common下说明这初始化是跟软件有关的。里面的内容为
			
			gd->have_console = 1;

	(2)display_banner
		
		1.用于串口输出显示uboot的logo

		2.使用printf函数向串口输出了version_string字符串。通过追踪printf发现：printf->puts，puts函数中会判断当前uboot中console是否被初始化好。
		
			如果console已初始化，则会调用fputs完成串口发送，这条线是使用控制台；
			如果console尚未初始化，则会调用serial_puts(里面再调用serial_putc直接操作串口寄存器进行内容发送)。

		3.使用控制台和不使用控制台的区别·

			a.控制台是一个用软件虚拟出来的设备，这套设备有专用的通信函数(发送、接收等)，控制台的通信函数最终会映射到硬件的通信函数来实现。
			
			b.因为uboot中实际上控制台的通信函数是直接映射到硬件串口的通信函数中的，所有uboot中用与不用控制台没有本质差别。

			c.但在别的体系中，控制台的通信函数映射到硬件通信函数时可以用软件来做中间优化。如：操作系统中控制台的缓冲机制。

		4.version_string	

			U_BOOT_VERSION不在uboot源代码中，这变量实际是在makefile中定义，在编译时生成include/version_autogenerated.h中用宏定义来实现。
			
		6.open_backlight
			
			打开LCD背光的函数。

	(3)print_cpuinfo
		
		1.在uboot启动过程中打印cpu信息：
			
		CPU:  S5PV210@1000MHz(OK)
			APLL = 1000MHz, HclkMsys = 200MHz, PclkMsys = 100MHz
			MPLL = 667MHz, EPLL = 96MHz
                       HclkDsys = 166MHz, PclkDsys = 83MHz
                       HclkPsys = 133MHz, PclkPsys = 66MHz
                       SCLKA2M  = 200MHz
		Serial = CLKUART
		
9.armboot函数解析7——init_sequence
	
	(1)checkboard
		
		1.函数作用是检查当前开发板时哪个开发板并打印出开发板的名字。

	(2)init_func_i2c
		
		1.初始化I2C的函数。
		
		2.CONFIG_HARD_I2C宏(硬件I2C)#undef，所以init_func_i2c没有执行。
		
		3.在程序员移植uboot时，可通过配置对应开发板参数来初始化I2C。

	(3)uboot学习实践
		
		1.烧录过程
			
			第一步：进入sd_fusing目录make clean后make。
			
			第二步：sd_fusing使用方法：./sd_fusing.sh /dev/sdb。

10.armboot函数解析8——init_sequence
	
	(1)dram_init	
	
		1.DDR初始化。汇编阶段是初始化硬件，这里是初始化软件。
		
		2.dram_init都是给gd->bd里面关于DDR配置部分的全局变量赋值。让gd->bd数据记录下当前开发板DDR的配置信息，以便uboot中使用内存。

		代码分析：
			
		1.106行的bi_dram是有两个元素的数组，表示有两片内存。

		2.bi_dram是的元素是结构体类型
			
			struct				/* RAM configuration */
			{
			ulong start;	//代表起始地址
			ulong size;		//代表大小
			}			bi_dram[CONFIG_NR_DRAM_BANKS];

	(2)display_dram_config
		
		1.打印显示dram配置信息的函数。启动信息中的：DRAM: 512 MB
		
		2.通过在uboot命令行输入bdinfo可获得DRAM信息：
			
			DRAM bank   = 0x00000000
			-> start    = 0x30000000
			-> size     = 0x10000000
			DRAM bank   = 0x00000001
			-> start    = 0x40000000
			-> size     = 0x10000000

	(3)init_sequence总结
	
		主要工作：板级硬件的初始化以及gd、gd->bd中的数据结构的初始化。如：
		
		1.网卡初始化、机器码(gd->bd->bi_arch_number、内核传参DDR地址(gd->bd->bi_boot_params)
		2.Timer4初始化为10ms一次
		3.波特率设置(gd->bd->bi_baudrate和gd->baudrate)
		4.串口初始化(实质没做什么，主要工作第一阶段已完成)
		5.console第一阶段初始化，gd->have_console设置为1。
		6.打印uboot的启动信息。
		7.打印CPU相关的设置信息。
		8.打印当前开发板名字。
		9.DDR配置信息的初始化(gd->bd->bi_dram)。
		10打印DDR总容量。

