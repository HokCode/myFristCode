继承相关：
	子类同名变量会覆盖父类同名变量。同名变量访问：
		Child c;
		c.mi = 100;				//子类中的mi
		c.Parent::mi = 1000;	//父类中的mi，作用域分辨符

	子类同名函数也会覆盖父类同名函数，不会重载。同名函数访问：
		Child c;
		c.add();
		c.Parent::add();		//作用域分辨符

	dynamic_cast继承相关的类型转换关键字
		1、相关类中必须有虚函数
		2、
		-指针：
			转换成功：得到目标类型指针
				失败：得到一个空指针
		-引用：
			转换成功：得到目标类型引用
				失败：得到一个异常操作信息

		Parent* p = new child;	//父类指针指向子类对象
		Child* pd = dynamic_cast<Child*>(p);	//转换成功

		Parent* p = new parent;
		Child* pd = dynamic_cast<Child*>(p);	//子类指针不能指向父类。转换失败，得到空指针

	纯虚函数
		1、父类中用virual修饰的函数
		2、用父类指针指向子类对象时，会调用子类的同名函数
			如：析构函数如果不用virtual修饰，那么用父类指针析构子类时，只会调用父类析构函数。子类的析构函数不会被执行。

写法相关：
	typename 与 class：
		如果需要告诉编译器变量是类型不是变量，需要用typename修饰。
		typename可以消除模板中二义性。

		例子：
			typename T::TS * a; //表明TS是类型名，不是变量名。编译器就知道是做定义指针操作，而不是乘法操作。

	mutable
		修饰的成员变量将永远处于可变状态。
		